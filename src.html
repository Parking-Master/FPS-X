<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS-X web shooter</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Montserrat:wght@500;900&display=swap");
      @font-face {
        font-family: "Arame";
        src: url(/fonts/Arame-Thin.ttf);
      }

      html, body {
        margin: 0;
        overflow: hidden !important;
        touch-action: none !important;
        user-select: none !important;
        -webkit-user-select: none !important;
        -khtml-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
        -webkit-touch-callout: none !important;
        background: #000;
      }
      * {
        touch-action: manipulation;
      }
      body {
        margin: 0;
        position: fixed;
        inset: 0;
        display: flex;
      }
      .vignette {
        position: relative;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        margin: 0;
        padding: 0;
        pointer-events: none !important;
        transition: opacity .15s;
      }
      .crosshair {
        position: absolute;
        width: 50px;
        height: 50px;
        left: 50%;
        top: 50%;
        margin-left: -25px;
        margin-top: -25px;
      }
      .hit-marker {
        position: absolute;
        width: 75px;
        height: 75px;
        left: 50%;
        top: 50%;
        margin-left: -37.5px;
        margin-top: -37.5px;
        visibility: hidden;
      }
      .ui {
        pointer-events: none !important;
        width: 1440px;
        height: 900px;
        position: fixed;
        left: 50%;
        margin-left: -720px;
        top: 50%;
        margin-top: -450px;
        transform: scale(.5);
        font-family: "Montserrat", sans-serif;
        z-index: 2147483645;
      }
      .row {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: row;
        justify-content: center;
        align-items: flex-end;
      }
      .column {
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      .left-ui {
        position: absolute;
        left: 100px;
        bottom: 50px; 
        background: rgba(1, 1, 1, 0);
        width: 400px;
        height: 120px;
        padding: 10px 10px;
        border-radius: 10px;
      }
      .right-ui {
        position: absolute;
        right: 100px;
        bottom: 50px; 
        background: transparent;
        width: 400px;
        height: 100px;
        padding: 10px 10px;
        border-radius: 10px;
      }
      .top-right-ui {
        position: absolute;
        right: 100px;
        top: 50px; 
        background: transparent;
        width: 400px;
        height: 100px;
        padding: 10px 10px;
        border-radius: 10px;
      }
      .top-left-ui {
        position: absolute;
        top: 200px; 
        background: transparent;
        width: 400px;
        height: 100px;
        border-radius: 10px;
      }
      .ui-area {
        display: flex;
        height: 100%;
        width: 100%;
        flex-direction: column;
        justify-content: flex-end;
      }
      .ui-glow {
        border-radius: 5px;
        box-shadow: inset -20px -40px 40px rgba(255, 255, 255, 0.125), 0 0 0 2px rgba(255, 255, 255, 0.5), inset -40px -60px 60px rgba(255, 255, 255, 0.125), 7px 7px 20px rgba(0, 0, 0, 0.3);
      }
      .left-ui-area {
        transform: perspective(600px) rotateY(30deg) rotatez(-3deg);
        padding-right: 50px;
      }
      .right-ui-area {
        transform: perspective(600px) rotateY(-30deg) rotatez(3deg);
      }
      .top-right-ui-area {
        transform: perspective(600px) rotateY(-30deg) rotatez(-3deg);
      }
      .top-left-ui-area {
        text-align: center;
      }
      .ammo-area {
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .ammo-area > .ammo-icon {
        margin: 5px;
      }
      .ammo-icon {
        width: 48px;
        height: 48px;
        filter: invert(1) drop-shadow(2px 2px 4px);
      }
      .weapon-text {
        color: white;
        text-shadow: 0px -2px 1px #ccc, 0px 2px 1px gray, 2px 2px 2px rgb(0, 0, 0);
        font-size: 16px;
      }
      .weapon-pic-text {
        color: white;
        text-shadow: 0px -2px 1px #ccc, 0px 2px 1px gray, 2px 2px 2px rgb(0, 0, 0);
        font-size: 32px;
      }
      .weapon-icon {
        width: 100px;
        height: 100px;
      }
      .weapon-icon img {
        position: relative;
        width: 100%;
        height: 100%;
        filter: drop-shadow(0px 0px 1px white) drop-shadow(0px 0px 1px white) drop-shadow(0px 0px 1px white);
      }
      .weapon-ammo-icon {
        display: inline-block;
        background-image: url("/images/icons/bullet.png");
        background-repeat: no-repeat;
        background-size: cover;
        height: 28px;
        width: 28px;
        margin-left: 5px;
        filter: invert(1) drop-shadow(1px 1px 3px #000);
      }
      .charge-area {
        margin: 10px;
        justify-content: right;
      }
      .charge-bar {
        height: 24px;
        width: 200px;
        background: rgba(0, 0, 0, .3);
        border-radius: 5px;
      }
      .charge-bar-active {
        height: 100%;
        background-color: #fff;
        border-radius: 5px;
        box-shadow: 0 0 10px rgb(255, 255, 255), inset 0 0 10px rgb(255, 255, 255);
      }
      .charge-text {
        color: #fff;
        text-shadow: 0px -2px 1px #ccc, 0px 2px 1px gray, 2px 2px 2px rgb(0, 0, 0);
        font-size: 24px;
      }
      .weapon-text-icon {
        background-repeat: no-repeat;
        background-size: cover;
        height: 24px;
        width: 24px;
        margin-left: 5px;
        filter: invert(1) drop-shadow(2px 2px 4px);
      }
      .weapon-pic-icon {
        background-size: contain;
        height: 40px;
        width: 40px;
        margin-left: 5px;
        filter: invert(1) drop-shadow(2px 2px 4px);
      }
      .weapon-area {
        margin-left: 10px;
      }
      .weapon-top-row {
        min-height: 30px;
        margin-bottom: 5px;
      }
      .charge-icon {
        background-image: url("/images/icons/bolt.png");
        background-size: contain;
        height: 24px;
        width: 24px;
      }
      .charge-icon-main {
        filter: invert(1) drop-shadow(1px 1px 3px);
      }
      .health-area {
        margin: 10px;
        justify-content: right;
      }
      .health-bar {
        height: 48px;
        width: 200px;
        margin: 5px;
        background: rgba(0, 0, 0, .3);
        border-radius: 5px;
      }
      .health-text {
        color: #fff;
        text-shadow: 0px -2px 1px #ccc, 0px 2px 1px gray, 2px 2px 2px rgb(0, 0, 0);
        font-size: 40px;
      }
      .health-icon {
        background-image: url("/images/icons/health.png");
        background-size: contain;
        height: 42px;
        width: 42px;
        margin-left: 5px;
      }
      .health-icon-main {
        filter: invert(1) drop-shadow(1px 1px 3px);
      }
      .health-bar-active {
        --box-shadow-default-green: 0 0 10px rgb(109, 201, 83), inset 0 0 10px rgb(196, 211, 227);
        --box-shadow-default-yellow: 0 0 10px rgb(255, 222, 33), inset 0 0 10px rgb(196, 211, 227);
        --box-shadow-default-red: 0 0 10px rgb(213, 0, 0), inset 0 0 10px rgb(196, 211, 227);
        --background-default-green: rgb(109, 201, 83);
        --background-default-yellow: rgb(255, 222, 33);
        --background-default-red: rgb(213, 0, 0);
        height: 100%;
        background-color: var(--background-default-green);
        border-radius: 5px;
        box-shadow: var(--box-shadow-default-green);
      }
      .weapon-magazine-icon {
        display: inline-block;
        background-image: url("/images/icons/magazine.png");
        background-repeat: no-repeat;
        background-size: cover;
        height: 28px;
        width: 28px;
        margin-left: 25px;
        filter: invert(1) drop-shadow(1px 1px 3px #000);
      }
      canvas {
        max-width: 100%;
        max-height: 100%;
        margin: auto;
      }
      .death-cam.death-cam-wrapper {
        position: absolute;
        width: 100%;
        left: 0;
        right: 0;
        bottom: 0;
        visibility: hidden;
      }
      .death-cam.death-cam-text.death-cam-username {
        position: relative;
        width: 400px;
        padding: 5px 0;
        left: 50%;
        margin-left: -200px;
        bottom: 60px;
        background: #e2e2e2;
        color: #000;
        font-family: "Arame", Arial;
        font-size: 18px;
        text-align: center;
        box-shadow: 0 0 6px rgb(255, 255, 255), inset 0 0 6px rgb(255, 255, 255);
      }
      .death-cam.death-cam-text.death-cam-username #username {
        font-size: 30px;
      }
      .ui .medal-wrapper {
        position: absolute;
        width: 600px;
        left: 50%;
        margin-left: -400px;
        top: 250px;
        color: #000;
        font-size: 25px;
        text-align: left;
      }
      .ui .medal {
        color: #ddd;
        margin-bottom: 10px;
        font-family: Arial;
        font-weight: 100;
        text-shadow: 0 0 2px black;
      }
      .ui .medal .medal-icon {
        width: 50px;
        vertical-align: middle;
        line-height: 25px;
        filter: invert(1);
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      @keyframes spin-reverse {
        0% {
          transform: rotate(360deg);
        }
        100% {
          transform: rotate(0deg);
        }
      }
      .clock.countdown {
        position: absolute;
        border: 10px solid #f3f3f3;
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
        border-top: 10px solid #333;
        border-radius: 50%;
        width: 200px;
        height: 200px;
        left: 50%;
        top: 50%;
        margin-left: -110px;
        margin-top: -110px;
        animation: spin 1s linear infinite;
        text-shadow: 0 0 2px #000;
        color: #ddd;
        font-size: 60px;
        visibility: hidden;
      }
      .clock.countdown-seconds {
        animation: spin-reverse 1s linear infinite;
        display: inline-block;
      }
      .weapon-name-display {
        font-size: 40px;
        text-align: left;
      }
      .ui .scoreboard {
        position: absolute;
        right: 0;
        bottom: 200px;
      }
      .ui .scoreboard .scoreboard-marker {
        background: linear-gradient(to right, transparent, rgba(230, 230, 230, 0.7));
        box-shadow: 0 0 1px rgb(255, 255, 255), inset 0 0 1px rgb(255, 255, 255);
        margin-bottom: 10px;
        width: 200px;
        padding: 10px;
        font-family: "Arame", Arial;
        color: #fff;
        text-shadow: 0 0 2px black;
        font-size: 16px;
        padding-left: 30px;
      }
      .ui .scoreboard .scoreboard-marker #value {
        font-size: 30px;
      }
      .ui .scoreboard .scoreboard-team {
        float: right;
        vertical-align: middle;
        line-height: 40px;
      }
      .game-over-banner {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.25);
        backdrop-filter: blur(2px);
        -webkit-backdrop-filter: blur(2px);
        display: none;
      }
      .game-over-banner .header {
        position: relative;
        font-family: "Arame", Arial;
        margin-top: 200px;
        font-size: 70px;
        color: #eee;
        text-align: center;
      }
      .game-over-banner .game-over-status {
        position: relative;
        font-family: "Arame", Arial;
        margin-top: 100px;
        font-size: 50px;
        color: #eee;
        text-align: center;
        visibility: hidden;
      }
      .ui .message-wrapper {
        position: absolute;
        width: 100%;
        left: 0;
        right: 0;
        bottom: 200px;
        opacity: 0;
      }
      .ui .message-wrapper .message {
        position: relative;
        text-align: center;
        font-family: "Arame", Arial;
        font-size:  35px;
        color: #eee;
        text-shadow: 0 0 3px black;
      }
      .ui .earned-medals {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        left: 50%;
        margin-left: -50%;
        margin-top: 100px;
      }
      .ui .earned-medals .medal {
        margin-left: 10px;
        margin-right: 10px;
      }
      .ui .total-points {
        position: relative;
        font-family: "Arame", Arial;
        margin-top: 30px;
        font-size: 30px;
        color: #eee;
        text-align: center;
        visibility: hidden;
      }
    </style>
  </head>
  <body>
    <!-- All of the pre-loaded scripts will go here -->
    <script src="/lib/user.js"></script>
    <script src="/lib/loading.js"></script>
    <script src="/lib/three.min.js"></script>
    <script src="/lib/GLTFLoader.min.js"></script>
    <script src="/lib/fflate.min.js"></script>
    <script src="/lib/Capsule.min.js"></script>
    <script src="/lib/Octree.min.js"></script>
    <script src="/lib/PointerLockControls.min.js"></script>
    <script src="/lib/GamepadControls.js"></script>
    <script src="/lib/TouchControls.min.js"></script>
    <script src="/lib/UI.js"></script>
    <script src="https://x.gametime.js.org/gametime.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Parking-Master/Gametime.js@latest/js/username-generator.min.js"></script>
    <script src="/lib/SkeletonUtils.js"></script>
    <script src="/lib/tween.min.js"></script>
    <script src="/lib/decalgeometry.js"></script>
    <script src="/lib/audio.js"></script>
    <script src="/lib/plugins.js"></script>
    <script src="/lib/text.js"></script>

    <!-- This is the main UI for the player -->
    <div class="ui" id="game-ui">
      <img class="vignette" src="images/other/vignette.png">
      <img class="hit-marker" src="images/icons/ui/hit-marker.png">
      <img class="crosshair" src="images/icons/ui/crosshair.png">

      <div class="medal-wrapper"></div>


      <div class="left-ui">
        <div class="ui-area ui-glow left-ui-area" id="left-ui-area">
          <div class="row">
            <div class="column">
              <div class="charge-text" id="charge-text">100%</div>
              <div class="health-text" id="health-text">100</div>
            </div>
            <div class="column">
              <div class="charge-icon charge-icon-main"></div>
              <div class="health-icon health-icon-main"></div>
            </div>
            <div class="column">
              <div class="charge-bar">
                <div class="charge-bar-active" id="charge-bar"></div>
              </div>
              <div class="health-bar">
                <div class="health-bar-active"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="right-ui">
        <div class="ui-area ui-glow right-ui-area" id="right-ui-area">
          <div class="row">
            <div class="column weapon-area">
              <div class="weapon-text weapon-top-row"></div>
              <div class="weapon-pic-text"><div class="weapon-ammo-icon"></div> <span class="weapon-ammo-number">36</span> <div class="weapon-magazine-icon"></div> <span class="weapon-magazine-number">4</span></div>
            </div>
            <div class="column weapon-area">
              <div class="weapon-text-icon weapon-top-row"></div>
              <div class="weapon-pic-icon"></div>
            </div>
            <div class="column weapon-area">
              <div class="weapon-icon">
                <img src="/images/other/weapons/AR-15.png">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="message-wrapper">
        <div class="message"></div>
      </div>
      <div class="scoreboard">
        <div class="scoreboard-marker scoreboard-marker-1"><span id="value">0</span> points <span class="scoreboard-team">You</span></div>
        <div class="scoreboard-marker scoreboard-marker-2"><span id="value">0</span> points <span class="scoreboard-team">Playe...</span></div>
      </div>
      <div class="death-cam death-cam-wrapper">
        <div class="death-cam death-cam-text death-cam-username">
          Killed by
          <span id="username" class="death-cam">username</span>
        </div>
      </div>
      <div class="clock countdown">
        <div class="clock countdown-seconds">10</div>
      </div>
      <div class="game-over-banner ignore">
        <div class="header ignore">GAME OVER</div>
        <div class="game-over-status ignore"><i class="fa fa-trophy ignore"></i> VICTORY <i class="fa fa-trophy ignore"></i></div>
        <div class="earned-medals ignore"></div>
        <div class="total-points ignore">
          <span class="ignore" id="value">0</span> TOTAL POINTS EARNED
        </div>
      </div>
    </div>
    <script>
      keyBindings = user.preferences.game.keyBindings;

      function params() {
        return Object.fromEntries(new URLSearchParams(location.search));
      }

      (async () => {
        if (!params().lobby) return alert(`Error: Missing required game parameter: lobby`), location.replace("/");
        // Setup Gametime.js-X for multiplayer

        // We'll try to connect to a Gametime.js-X socket server, but will use PubNub instead if not available
        await gametime.setCustomServer(["http://weatherstationpi.local:4444", "https://caribou-needed-implicitly.ngrok-free.app", "https://new-suitably-gnu.ngrok-free.app", "https://gratefully-engaged-bluebird.ngrok-free.app"]);
        await gametime.set("channel", params().lobby);
        await gametime.set("key", "pub-c-99b84afd-1fa3-4452-a727-4b46d06a11e2", "sub-c-ed7e8e7f-1c0a-40ec-bc97-7da421c062a0");
        await gametime.sustain();

        gametime.on("join", async function(player, uuid, customCharacter, username) {
          if (opposingPlayerObjects.map(object => object.uuid).indexOf(uuid) > -1) return;
          if (Object.keys(utils.scoreboard.teams).includes(username)) return;
          window.LoadingManager.playerJoin(uuid, username);

          utils.scoreboard.addTeam(username);

          let characterMaps = {
            "SWAT": "character",
            "GasMask": "character1",
            "Marine": "character2"
          };
          let selectedCharacter = characterMaps[customCharacter];

          await plugins.waitUntil(() => sandbox.models[selectedCharacter].loaded);
          let playerObject = await reloadModel(selectedCharacter);
          playerObject.name = `Player_${player}_Character`;
          playerObject.uuid = uuid;
          playerObject.username = username;
          playerObject.model.traverse(object => {
            object.userData.player = player;
            object.userData.playerUUID = uuid;
            object.userData.username = username;
          });
          playerObject.model.position.y = -1000;

          scene.add(playerObject.model);

          let myPlayerObject = {
            model: new THREE.Mesh(),
            name: `Player_${opposingPlayerObjects.length}_Character`,
            uuid: gametime.player.uuid,
            username: sandbox.username
          }
          if (opposingPlayerObjects.length == gametime.player.position - 1) opposingPlayerObjects.push(myPlayerObject);
          opposingPlayerObjects.push(playerObject);

          let aimingObjects = utils.cache.read("raycaster", "aimingObjects");
          aimingObjects.push(playerObject.model.getObjectByName("BodyFollower"), playerObject.model.getObjectByName("HeadFollower"), playerObject.model.getObjectByName("AimFollower"));
          utils.cache.write("raycaster", "aimingObjects", aimingObjects);

          utils.player.playerCache.create(uuid);
          utils.player.playerCache.set(uuid, "health", 100);
          utils.player.playerCache.set(uuid, "healthIncrementInterval", 0);
          utils.player.playerCache.set(uuid, "healthIncrementTimeout", 0);
          utils.player.playerCache.set(uuid, "armAnimationType", "barrel");
          utils.player.playerCache.set(uuid, "dying", false);

          utils.player.animations.play(playerObject, "rifle_idle");

          let character = params().character || "SWAT";
          gametime.run("join", [gametime.player.position, gametime.player.uuid, character, sandbox.username]);
        });

        // All multiplayer functions go here
        gametime.on("move", function(uuid, direction, speed, animation) {
          if (uuid == gametime.player.uuid) return;

          let playerObject = utils.player.getObject(uuid);
          if (direction === "forward") playerObject.model.translateZ(-speed);
          if (direction === "left") playerObject.model.translateX(-speed);
          if (direction === "backward") playerObject.model.translateZ(speed);
          if (direction === "rights") playerObject.model.translateX(speed);
          if (direction === "fixed") {
            if (playerObject.jumping) {
              playerObject.model.position.x = speed.split(",")[0] - 0;
              playerObject.model.position.z = speed.split(",")[2] - 0;
            } else {
              playerObject.model.position.set(speed.split(",")[0] - 0, speed.split(",")[1] - 1, speed.split(",")[2] - 0);
            }
          }

          if (animation && !playerObject.walking) {
            utils.player.animations.fade(playerObject, "idle", "walking", 1);
          }

          playerObject.walking = true;
        });

        gametime.on("halt", function(uuid) {
          if (uuid == gametime.player.uuid) return;

          let playerObject = utils.player.getObject(uuid);
          playerObject.walking = false;

          utils.player.animations.fade(playerObject, "walking", "idle", 1);
        });

        gametime.on("rotate", function(uuid, vector) {
          if (uuid == gametime.player.uuid) return;

          // Here is an opportunity for updating the player's position while they look around
          let playerObject = utils.player.getObject(uuid);
          if (!playerObject.jumping) {
            let position = new THREE.Vector3(vector.split(",")[3] - 0, vector.split(",")[4] - 0, vector.split(",")[5] - 0);
            playerObject.model.position.set(position.x, position.y - 1, position.z);
          }

          let rotation = new THREE.Vector3(vector.split(",")[0] - 0, vector.split(",")[1] - 0, vector.split(",")[2] - 0);
          playerObject.model.rotation.order = "YXZ";
          playerObject.model.rotation.y = rotation.y;
          // if (!opposingPlayerObjects[player - 1].walking) opposingPlayerObjects[player - 1].model.getObjectByName("mixamorigHead").rotation.x = -(rotation.x + .1);
        });

        gametime.on("jump", function(uuid) {
          if (uuid == gametime.player.uuid) return;

          let playerObject = utils.player.getObject(uuid);
          playerObject.jumping = true;

          utils.player.animations.play(playerObject, "jumping", () => {
            playerObject.jumping = false;
          });
        });

        gametime.on("playerHit", function(uuid, opposingUUID, damage, headshot, grenadeType) {
          if (uuid != gametime.player.uuid) {
            utils.player.health.decrease(uuid, opposingUUID, damage, headshot);
            return;
          }
          // Decrease health and add death effects here
          let opposingPlayer = utils.player.getObject(opposingUUID).model;
          utils.health.decrease(damage, opposingPlayer);
          gametime.run("playerUpdate", [gametime.player.uuid, opposingUUID, utils.options.get("Health")]);
        });

        gametime.on("playerUpdate", function(uuid, opposingUUID, health) {
          // In case of any discrepancies, update real-time player information here
          if (uuid == gametime.player.uuid) return;

          utils.player.health.set(uuid, opposingUUID, health);
        });

        gametime.on("playerRespawn", async function(uuid, spawnVector, initial) {
          if (uuid == gametime.player.uuid) return;

          if (initial) await plugins.waitUntil(() => utils.player.getObject(uuid));
          let spawnPoint = [spawnVector.split(",")[0] - 0, spawnVector.split(",")[1] - 0, spawnVector.split(",")[2] - 0, spawnVector.split(",")[3] - 0, spawnVector.split(",")[4] - 0, spawnVector.split(",")[5] - 0];
          utils.player.respawn(uuid, spawnPoint);
        });

        gametime.on("weaponSwitch", function(uuid, weapon) {
          if (uuid == gametime.player.uuid) return;

          utils.player.weapon.switch(uuid, weapon);
        });

        gametime.on("weaponDrop", function(uuid, firstWeapon, secondWeapon) {
          if (uuid == gametime.player.uuid) return;

          function next(weapon) {
            let position = new THREE.Vector3(weapon.position.split(",")[0], weapon.position.split(",")[1], weapon.position.split(",")[2]);
            let rotation = new THREE.Euler(weapon.rotation.split(",")[0], weapon.rotation.split(",")[1], weapon.rotation.split(",")[2], "YXZ");
            utils.weapons.spawn(weapon.name, position, rotation, false, true, { ammo: weapon.ammo, magazines: weapon.magazines });
          }

          next(firstWeapon);
          if (secondWeapon) next(secondWeapon);
        });

        gametime.on("weaponEffectBulletHole", function(uuid, intersection, ammoType) {
          if (uuid == gametime.player.uuid) return;

          let intersect = {
            face: {
              normal: new THREE.Vector3(intersection.faceNormal.x, intersection.faceNormal.y, intersection.faceNormal.z)
            },
            object: map.getObjectByName(intersection.objectName),
            point: new THREE.Vector3(intersection.point.x, intersection.point.y, intersection.point.z)
          };
          if (typeof intersect.object === "undefined") return;

          let bulletHoleTexture = utils.cache.read("bulletHole", ammoType);
          const size = new THREE.Vector3(0.05, 0.05, 0.05);
          const normal = intersect.face.normal;
          normal.transformDirection(intersect.object.matrixWorld);
          const rotation = new THREE.Euler().setFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), normal));

          const decalMaterial = new THREE.MeshPhongMaterial({
            map: bulletHoleTexture,
            transparent: true,
            depthTest: true,
            depthWrite: false,
            polygonOffset: true,
            polygonOffsetFactor: -4,
            side: THREE.DoubleSide
          });
          const decalGeometry = new THREE.DecalGeometry(intersect.object, intersect.point, rotation, size);

          const decalMesh = new THREE.Mesh(decalGeometry, decalMaterial);
          scene.add(decalMesh);

          async function dispose() {
            let fadeTime = 2000;
            new TWEEN.Tween(decalMaterial).to({ opacity: 0 }, fadeTime).easing(TWEEN.Easing.Quadratic.Out).start();
            await plugins.delay(fadeTime);
            scene.remove(decalMesh);
            decalMaterial.map.dispose();
            decalMaterial.dispose();
            decalGeometry.dispose();
            bulletHoleTexture = null;
            raycaster = null;
          }

          setTimeout(dispose, 10000);
        });

        gametime.on("weaponEffectShoot", function(uuid, weapon) {
          if (uuid == gametime.player.uuid) return;

          let playerObject = utils.player.getObject(uuid);
          THREE.Sound(`preloaded:shooting3d_${weapon}`, true, playerObject.model, () => {}, 2, 0.5);
        });

        gametime.on("weaponEffectGrenadeToss", function(uuid, grenadeUUID, vector) {
          if (uuid == gametime.player.uuid) return;

          let playerObject = utils.player.getObject(uuid);
          THREE.Sound(`preloaded:grenadetoss3d`, true, playerObject.model, () => {}, 5);

          const grenadeId = utils.weapons.grenades.getAvailable();
          const grenade = grenades[grenadeId];
          grenade.available = false;
          grenade.uuid = grenadeUUID;
          grenade.explode = false;

          let fakeCamera = camera.clone();
          let fakePlayerDirection = playerDirection.clone();
          let fakePlayerCollider = playerCollider.clone();
          let fakePlayerVelocity = playerVelocity.clone();
          fakePlayerDirection.x = vector.split(",")[3] - 0;
          fakePlayerDirection.y = vector.split(",")[4] - 0;
          fakePlayerDirection.z = vector.split(",")[5] - 0;
          fakePlayerCollider.end.x = vector.split(",")[0] - 0;
          fakePlayerCollider.end.y = vector.split(",")[1] - 0;
          fakePlayerCollider.end.z = vector.split(",")[2] - 0;
          fakePlayerVelocity.x = vector.split(",")[9] - 0;
          fakePlayerVelocity.y = vector.split(",")[10] - 0;
          fakePlayerVelocity.z = vector.split(",")[11] - 0;
          fakeCamera.rotation.set(vector.split(",")[6] - 0, vector.split(",")[7] - 0, vector.split(",")[8] - 0);
          fakeCamera.getWorldDirection(fakePlayerDirection);

          grenade.collider.center.copy(fakePlayerCollider.end).addScaledVector(fakePlayerDirection, playerCollider.radius * 1.5);
          const impulse = 40;
          grenade.velocity.copy(fakePlayerDirection).multiplyScalar(impulse);
          grenade.velocity.addScaledVector(fakePlayerVelocity, 2);
          scene.add(grenade.mesh);

          // Just in case the grenade never explodes, we'll reset it after a certain time
          let resetId = grenade.resetId.toString();
          setTimeout(() => {
            if (grenades[grenade.id].resetId === resetId) utils.weapons.grenades.reset(grenade.id);
          }, 10000);

          utils.player.animations.play(playerObject, "grenade_throw");
        });

        gametime.on("weaponEffectGrenadeExplode", function(uuid, grenadeUUID, vector) {
          if (uuid == gametime.player.uuid) return;

          if (!grenadeUUID) return;

          let position = new THREE.Vector3();
          position.x = vector.split(",")[0] - 0;
          position.y = vector.split(",")[0] - 0;
          position.z = vector.split(",")[0] - 0;

          let grenade = grenades.filter(x => x.uuid === grenadeUUID)[0];
          grenade.collider.set(position.x, position.y, position.z);
          utils.weapons.grenades.explosion(grenade.mesh, grenade.id, 0, false);
        });

        gametime.on("weaponDespawn", function(uuid, id, dropWeapon) {
          if (uuid == gametime.player.uuid) return;

          let deployedCrateIds = Object.keys(deployedCrates);
          let crateId = deployedCrateIds.filter(uuid => uuid.endsWith(id))[0];

          if (!crateId) return;
          utils.weapons.despawn(crateId, dropWeapon);
        });
      })();

      const renderOptions = {
        antialias: true,
        alpha: true,
        powerPreference: "high-performance"
      };
      const playerDefaultPosition = {
        x: 13.5,
        y: .35,
        z: -18.5
      };
      const vector2 = new THREE.Vector2();
      const vector3 = new THREE.Vector3();
      const vector4 = new THREE.Vector4();
      const _vector1 = new THREE.Vector3();
      const _vector2 = new THREE.Vector3();
      const _vector3 = new THREE.Vector3();

      let keyStates = {};
      let keyRepeats = {};
      let opposingPlayerObjects = [];
      let playerOnFloor = false;
      let previousTouch = null;
      let allowedToJump = true;

      const STEPS_PER_FRAME = 4;
      const GRAVITY = 40;
      const grenades = [];

      async function loadGrenades() {
        const grenadeAmount = 3;

        await plugins.waitUntil(() => sandbox.models["weapon_Grenade-Frag"].loaded);
        for (let i = 0; i < grenadeAmount; i++) {
          const grenade = sandbox.models["weapon_Grenade-Frag"].model.clone();
          grenade.traverse(object => {
            if (object.material) {
              if (object.material.map) renderer.initTexture(object.material.map);
              if (object.material.normalMap) renderer.initTexture(object.material.normalMap);
              if (object.material.roughnessMap) renderer.initTexture(object.material.roughnessMap);
            }
          });

          // We'll pre-render the grenade so it doesn't cause compilation stutter when actually used
          utils.precompileShaders(grenade);

          grenades.push({
            mesh: grenade,
            collider: new THREE.Sphere(new THREE.Vector3(0, -100, 0), 0.1),
            velocity: new THREE.Vector3(),
            angularVelocity: new THREE.Vector3(),
            available: true,
            hits: 0,
            explode: true,
            uuid: null,
            id: i,
            resetId: gametime.uuidv4()
          });
        }
      }

      // Default properties (sorted most important first)
      const renderer = new THREE.WebGLRenderer(renderOptions);
      const weaponRenderer = new THREE.WebGLRenderer(renderOptions);
      const scene = new THREE.Scene();
      const weaponScene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, 1440 / 900, 0.1, 1000);
      const weaponCamera = new THREE.PerspectiveCamera(60, 1440 / 900, 0.1, 1000);
      const clock = new THREE.Clock();
      const worldOctree = new THREE.Octree();
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      const hemisphereLight = new THREE.HemisphereLight(0xa1c5e0, 0x002244, 0.5);

      // Player setup
      const playerCollider = new THREE.Capsule(new THREE.Vector3(0, .35, 0), new THREE.Vector3(0, 1, 0), .35);
      const playerVelocity = vector3.clone();
      const playerDirection = vector3.clone();

      let deployedCrates = {};
      let lastRuntime = 0;
      const runtimeInterval = 100;
      const ignoreLayer = new THREE.Layers();
      ignoreLayer.set(1);
      ignoreLayer.set(2);
      ignoreLayer.set(3);
      camera.layers.enable(1);
      camera.layers.enable(2);
      camera.layers.enable(3);
      // Set an object to Layer 1 if you don't want any interception by raycasters.
      // Set an object to Layer 2 if you don't want any interception by raycasters for bullet effects.
      // Set an object to Layer 3 if the object is part of the bullet effects.

      // Default property configuration (camera, scene, renderer, etc.)
      renderer.setPixelRatio(window.devicePixelRatio - 0.2);
      renderer.setSize(1440, 900);
      renderer.setClearAlpha();
      renderer.setClearColor(0x000000, 0);
      weaponRenderer.setClearAlpha();
      weaponRenderer.setClearColor(0x000000, 0);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.VSMShadowMap;
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;

      renderer.domElement.style = "";
      renderer.domElement.width = "1440";
      renderer.domElement.height = "900";
      renderer.setViewport(0, 0, (1440 / 2) + 80, (900 / 2) + 50);

      weaponRenderer.setPixelRatio(window.devicePixelRatio - 0.2);
      weaponRenderer.setSize(1440, 900);
      weaponRenderer.domElement.style = "position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); pointer-events: none !important";
      weaponRenderer.domElement.width = "1440";
      weaponRenderer.domElement.height = "900";
      weaponRenderer.setViewport(0, 0, (1440 / 2) + 80, (900 / 2) + 50);
      weaponRenderer.outputEncoding = THREE.sRGBEncoding;
      weaponRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      camera.rotation.order = "YXZ";
      weaponCamera.rotation.order = "YXZ";
      playerCollider.start.set(playerDefaultPosition.x, playerDefaultPosition.y, playerDefaultPosition.z);
      playerCollider.end.set(playerDefaultPosition.x, playerDefaultPosition.y + .65, playerDefaultPosition.z);
      directionalLight.position.set(-5, 25, -1);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.near = .01;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.camera.right = 30;
      directionalLight.shadow.camera.left = -30;
      directionalLight.shadow.camera.top = 30;
      directionalLight.shadow.camera.bottom = -30;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      directionalLight.shadow.radius = 4;
      directionalLight.shadow.bias = -0.00006;
      hemisphereLight.position.set(2, 1, 1);
      document.body.appendChild(renderer.domElement);
      document.body.appendChild(weaponRenderer.domElement);

      // Add all of these default properties to the scene(s)
      scene.add(hemisphereLight);
      scene.add(directionalLight);
      weaponScene.add(hemisphereLight.clone());
      weaponScene.add(directionalLight.clone());

      function animate() {
        // Here we'll set up two deltas. Once for animations (default delta time) and one for player controls (relative delta time)
        const clockDelta = clock.getDelta() * sandbox.presets.animationSpeed;
        const deltaTime = Math.min(0.05, clockDelta) / STEPS_PER_FRAME;

        // Render the scenes and repeat the loop
        renderer.render(scene, camera);
        weaponRenderer.render(weaponScene, weaponCamera);

        // Everything that needs to be repeated goes here
        if (utils.options.get("CameraLocked")) camera.position.copy(playerCollider.end);

        for (let i = 0; i < Object.keys(sandbox.models).length; i++) {
          let model = Object.keys(sandbox.models)[i];
          if (sandbox.models[model].mixer && sandbox.models[model].animations) {
            sandbox.models[model].mixer.update(clockDelta);
          }
        }

        for (let i = 0; i < opposingPlayerObjects.length; i++) {
          let model = opposingPlayerObjects[i];
          if (model.mixer && model.animations) {
            model.mixer.update(clockDelta);
          }
        }

        for (i in deployedCrates) {
          let crate = deployedCrates[i];
          if (crate) {
            let index = i.split(":")[1];
            if (camera.position.distanceTo(crate.position) < 1.5) {
              if (!crate.userData.messageShown) {
                deployedCrates[i].userData.messageShown = true;
                utils.effects.showMessage(`Press [E] to pick up ${crate.userData.weaponName}`, index);
              }
              if (sandbox.loadout.includes(crate.userData.weaponName) && !utils.options.get("Dying")) {
                let options = {};
                if (typeof crate.userData.ammo !== "undefined") options.ammo = crate.userData.ammo;
                if (typeof crate.userData.magazines !== "undefined") options.magazines = crate.userData.magazines;
                utils.weapons.despawn(i, false);
                utils.weapons.pickUp(crate.userData.weaponName, options);
              } else if (keyStates[keyBindings.interact] && !keyRepeats[keyBindings.interact]) {
                keyRepeats[keyBindings.interact] = true;
                let options = {};
                if (typeof crate.userData.ammo !== "undefined") options.ammo = crate.userData.ammo;
                if (typeof crate.userData.magazines !== "undefined") options.magazines = crate.userData.magazines;
                utils.weapons.despawn(i);
                utils.weapons.pickUp(crate.userData.weaponName, options);
              }
            } else {
              deployedCrates[i].userData.messageShown = false;
              utils.effects.hideMessage(index);
            }
          }
        }

        // Update everything that needs to be updated here
        teleportPlayerIfOob();
        const currentRuntime = performance.now();
        if (utils.options.get("CameraTurning")) {
          utils.camera.updateVision();
        } else if (currentRuntime - lastRuntime > runtimeInterval) {
          utils.camera.updateVision();

          lastRuntime = currentRuntime;
        }

        TWEEN.update();
        THREE.Text.update();
        for (let i = 0; i < STEPS_PER_FRAME; i++) {
          controls(deltaTime);
          updatePlayer(deltaTime);
          updateGrenades(deltaTime);
          utils.camera.updatePosition();
          utils.weapons.updatePosition();
        }
        requestAnimationFrame(animate);
      }

      // Global variables go here
      let nullObject = new THREE.Group();
      let map = nullObject;

      // Global properties go here
      sandbox = {
        presets: {
          killPoints: 10,
          scoreLimit: 100,
          animationSpeed: 1
        },
        username: user.username || generateName(),
        map: null,
        primaryWeapon: null,
        secondaryWeapon: null,
        currentWeapon: null,
        models: {
          "character": {
            "name": "character",
            "loaded": false,
            "model": null,
            "path": "/models/characters/SWAT.glb",
            "callback": function(model) {
              model.scene.traverse(object => {
                if (object.name !== "BodyFollower" && object.name !== "HeadFollower" && object.name !== "AimFollower") object.layers.set(1);
                if (object.name === "AimFollower") object.layers.set(2);
                object.frustumCulled = false;
              });
              model.scene.scale.set(.0072, .0072, .0072);
            }
          },
          "character1": {
            "name": "character1",
            "loaded": false,
            "model": null,
            "path": "/models/characters/GasMask.glb",
            "callback": function(model) {
              model.scene.traverse(object => {
                if (object.name !== "BodyFollower" && object.name !== "HeadFollower" && object.name !== "AimFollower") object.layers.set(1);
                if (object.name === "AimFollower") object.layers.set(2);
                object.frustumCulled = false;
              });
              model.scene.scale.set(.0072, .0072, .0072);
            }
          },
          "character2": {
            "name": "character2",
            "loaded": false,
            "model": null,
            "path": "/models/characters/Marine.glb",
            "callback": function(model) {
              model.scene.traverse(object => {
                if (object.name !== "BodyFollower" && object.name !== "HeadFollower" && object.name !== "AimFollower") object.layers.set(1);
                if (object.name === "AimFollower") object.layers.set(2);
                object.frustumCulled = false;
              });
              model.scene.scale.set(.0072, .0072, .0072);
            }
          },
          "weapon_AK-74": {
            "name": "AK-74",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/AK-74.glb",
            "callback": function(model) {}
          },
          "weapon_AR-15": {
            "name": "AR-15",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/AR-15.glb",
            "callback": function(model) {}
          },
          "weapon_M16": {
            "name": "M16",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/M16.glb",
            "callback": function(model) {}
          },
          "weapon_MK-14": {
            "name": "MK-14",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/MK-14.glb",
            "callback": function(model) {}
          },
          "weapon_SCAR-H": {
            "name": "SCAR-H",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/SCAR-H.glb",
            "callback": function(model) {}
          },
          "weapon_SKS": {
            "name": "SKS",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/SKS.glb",
            "callback": function(model) {}
          },
          "weapon_Glock-19": {
            "name": "Glock-19",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/Glock-19.glb",
            "callback": function(model) {}
          },
          "weapon_XD-Mod-2": {
            "name": "XD-Mod-2",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/XD-Mod-2.glb",
            "callback": function(model) {
              model.scene.traverse(object => object.frustumCulled = false);
            }
          },
          "weapon_FN-502": {
            "name": "FN-502",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/FN-502.glb",
            "callback": function(model) {}
          },
          "weapon_Desert-Eagle": {
            "name": "Desert-Eagle",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/Desert-Eagle.glb",
            "callback": function(model) {}
          },
          "weapon_Railgun": {
            "name": "Railgun",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/Railgun.glb",
            "callback": function(model) {}
          },
          "weapon_Precision-Railgun": {
            "name": "Precision-Railgun",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/Precision-Railgun.glb",
            "callback": function(model) {}
          },
          "weapon_HK-G28": {
            "name": "HK-G28",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/HK-G28.glb",
            "callback": function(model) {
              model.scene.getObjectByName("ObjectHolder_RightHand").visible = false;
            }
          },
          "weapon_AWP-L96": {
            "name": "AWP-L96",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/AWP-L96.glb",
            "callback": function(model) {
              model.scene.getObjectByName("ObjectHolder_RightHand").visible = false;
            }
          },
          "weapon_M40a3": {
            "name": "M40a3",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/M40a3.glb",
            "callback": function(model) {
              model.scene.getObjectByName("ObjectHolder_RightHand").visible = false;
            }
          },
          "weapon_Barrett-50cal": {
            "name": "Barrett-50cal",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/Barrett-50cal.glb",
            "callback": function(model) {
              model.scene.getObjectByName("ObjectHolder_RightHand").visible = false;
            }
          },
          "weapon_Remington-870": {
            "name": "Remington-870",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/Remington-870.glb",
            "callback": function(model) {}
          },
          "weapon_Keltec-KSG": {
            "name": "Keltec-KSG",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/Keltec-KSG.glb",
            "callback": function(model) {}
          },
          "weapon_Drum-Shotgun": {
            "name": "Drum-Shotgun",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/Drum-Shotgun.glb",
            "callback": function(model) {}
          },
          "weapon_Grenade-Launcher": {
            "name": "Grenade-Launcher",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/Grenade-Launcher.glb",
            "callback": function(model) {}
          },
          "weapon_Rocket-Launcher": {
            "name": "Rocket-Launcher",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/Rocket-Launcher.glb",
            "callback": function(model) {}
          },
          "weapon_RPG-7": {
            "name": "RPG-7",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/RPG-7.glb",
            "callback": function(model) {}
          },
          "weapon_M60": {
            "name": "M60",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/M60.glb",
            "callback": function(model) {}
          },
          "weapon_Grenade-Frag": {
            "name": "Grenade-Frag",
            "loaded": false,
            "model": null,
            "path": "/models/weapons/grenades/Frag.glb",
            "callback": function(model) {
              model.scene.scale.set(.1, .1, .1);
            }
          },
          "propweapon_AK-74": {
            "name": "AK-74",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/AK-74.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_AR-15": {
            "name": "AR-15",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/AR-15.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_M16": {
            "name": "M16",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/M16.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_MK-14": {
            "name": "MK-14",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/MK-14.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_SCAR-H": {
            "name": "SCAR-H",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/SCAR-H.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_SKS": {
            "name": "SKS",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/SKS.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_Glock-19": {
            "name": "Glock-19",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/Glock-19.glb",
            "callback": function(model) {},
            "armAnimationType": "handheld"
          },
          "propweapon_XD-Mod-2": {
            "name": "XD-Mod-2",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/XD-Mod-2.glb",
            "callback": function(model) {
              model.scene.traverse(object => object.frustumCulled = false);
            },
            "armAnimationType": "handheld"
          },
          "propweapon_FN-502": {
            "name": "FN-502",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/FN-502.glb",
            "callback": function(model) {},
            "armAnimationType": "handheld"
          },
          "propweapon_Desert-Eagle": {
            "name": "Desert-Eagle",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/Desert-Eagle.glb",
            "callback": function(model) {},
            "armAnimationType": "handheld"
          },
          "propweapon_Railgun": {
            "name": "Railgun",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/Railgun.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_Precision-Railgun": {
            "name": "Precision-Railgun",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/Precision-Railgun.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_HK-G28": {
            "name": "HK-G28",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/HK-G28.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_AWP-L96": {
            "name": "AWP-L96",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/AWP-L96.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_M40a3": {
            "name": "M40a3",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/M40a3.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_Barrett-50cal": {
            "name": "Barrett-50cal",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/Barrett-50cal.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_Remington-870": {
            "name": "Remington-870",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/Remington-870.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_Keltec-KSG": {
            "name": "Keltec-KSG",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/Keltec-KSG.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_Drum-Shotgun": {
            "name": "Drum-Shotgun",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/Drum-Shotgun.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_Grenade-Launcher": {
            "name": "Grenade-Launcher",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/Grenade-Launcher.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_Rocket-Launcher": {
            "name": "Rocket-Launcher",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/Rocket-Launcher.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_RPG-7": {
            "name": "RPG-7",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/RPG-7.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "propweapon_M60": {
            "name": "M60",
            "loaded": false,
            "model": null,
            "path": "/models/characters/weapon-props/M60.glb",
            "callback": function(model) {},
            "armAnimationType": "barrel"
          },
          "explosion": {
            "name": "explosion",
            "loaded": false,
            "model": null,
            "path": "/models/assets/explosion.glb",
            "callback": function(model) {
              model.scene.scale.set(.3, .3, .3);
              model.scene.position.y = -1000;

              // We'll pre-render the explosion so it doesn't cause compilation stutter when actually used
              model.scene.traverse(object => {
                object.frustumCulled = false;
                object.layers.set(1);
                if (object.material) {
                  if (object.material.map) renderer.initTexture(object.material.map);
                  if (object.material.normalMap) renderer.initTexture(object.material.normalMap);
                  if (object.material.roughnessMap) renderer.initTexture(object.material.roughnessMap);
                }
              });
              utils.precompileShaders(model.scene);
            }
          },
          "crate": {
            "name": "crate",
            "loaded": false,
            "model": null,
            "path": "/models/assets/weapon_box.glb",
            "callback": function(model) {}
          },
        },
        weapons: {
          "AK-74": {
            name: "AK-74",
            ammoCapacity: 30,
            ammoCurrent: 30,
            ammoType: "rifle",
            magazineCurrent: 4,
            magazineCapacity: 4,
            firingModes: ["semi", "full", "burst"],
            currentFiringMode: "full",
            fireRates: {
              "semi": 92,
              "full": 92,
              "burst": 10
            },
            animationStructure: {
              idle: [0, 1],
              draw: [1, 1],
              walk: [2, 1],
              run: [3, 1],
              shoot: [4, 1],
              reload: [5, 1],
              reload_full: [7, 1]
            },
            damage: 5,
            headshotDamage: 8,
            reloadDelay: null
          },
          "AR-15": {
            name: "AR-15",
            ammoCapacity: 30,
            ammoCurrent: 30,
            ammoType: "rifle",
            magazineCurrent: 3,
            magazineCapacity: 3,
            firingModes: ["semi", "full", "burst"],
            currentFiringMode: "full",
            fireRates: {
              "semi": 63,
              "full": 63,
              "burst": 15
            },
            animationStructure: {
              idle: [0, 1],
              draw: [1, 1],
              walk: [2, 1],
              run: [3, 1],
              shoot: [4, 1],
              reload: [5, 1],
              reload_full: [7, 1]
            },
            damage: 10,
            headshotDamage: 12,
            reloadDelay: null
          },
          "M16": {
            name: "M16",
            ammoCapacity: 18,
            ammoCurrent: 18,
            ammoType: "rifle",
            magazineCurrent: 3,
            magazineCapacity: 3,
            firingModes: ["semi", "full", "burst"],
            currentFiringMode: "burst",
            fireRates: {
              "semi": 63,
              "full": 63,
              "burst": 15
            },
            animationStructure: {
              idle: [0, 1],
              draw: [1, 1],
              walk: [2, 1],
              run: [3, 1],
              shoot: [4, 1],
              reload: [5, 1],
              reload_full: [7, 1]
            },
            triggerDelay: 400,
            damage: 10,
            headshotDamage: 20,
            reloadDelay: null,
            muzzleFlash: {
              enabled: true,
              x: 0.15,
              y: -0.1,
              z: -1.5
            }
          },
          "MK-14": {
            name: "MK-14",
            ammoCapacity: 20,
            ammoCurrent: 20,
            ammoType: "rifle",
            magazineCurrent: 4,
            magazineCapacity: 4,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 250,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [0, 1],
              draw: [1, 1],
              walk: [2, 1],
              run: [3, 1],
              shoot: [4, 1],
              reload: [5, 1],
              reload_full: [7, 1]
            },
            triggerDelay: 300,
            damage: 20,
            headshotDamage: 40,
            reloadDelay: null,
            muzzleFlash: {
              enabled: true,
              x: 0.15,
              y: -0.05,
              z: -2
            }
          },
          "SCAR-H": {
            name: "SCAR-H",
            ammoCapacity: 10,
            ammoCurrent: 10,
            ammoType: "rifle",
            magazineCurrent: 3,
            magazineCapacity: 3,
            firingModes: ["semi", "full"],
            currentFiringMode: "full",
            fireRates: {
              "semi": 90,
              "full": 90,
              "burst": 0
            },
            animationStructure: {
              idle: [0, 1],
              draw: [1, 1],
              walk: [2, 1],
              run: [3, 1],
              shoot: [4, 1],
              reload: [5, 1],
              reload_full: [7, 1]
            },
            damage: 20,
            headshotDamage: 25,
            reloadDelay: null
          },
          "SKS": {
            name: "SKS",
            ammoCapacity: 10,
            ammoCurrent: 10,
            ammoType: "rifle",
            magazineCurrent: 2,
            magazineCapacity: 2,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 400,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [0, 1],
              draw: [1, 1],
              walk: [2, 1],
              run: [3, 1],
              shoot: [4, 1],
              reload: [5, 1],
              reload_full: [7, 1]
            },
            triggerDelay: 600,
            damage: 40,
            headshotDamage: 100,
            reloadDelay: null
          },
          "Glock-19": {
            name: "Glock-19",
            ammoCapacity: 15,
            ammoCurrent: 15,
            ammoType: "pistol",
            magazineCurrent: 2,
            magazineCapacity: 2,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 150,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [1, .1],
              walk: [0, 1],
              shoot: [2, 1],
              reload: [3, 1],
              reload_full: [4, 1]
            },
            damage: 6,
            headshotDamage: 9,
            reloadDelay: null
          },
          "XD-Mod-2": {
            name: "XD-Mod-2",
            ammoCapacity: 9,
            ammoCurrent: 9,
            ammoType: "pistol",
            magazineCurrent: 2,
            magazineCapacity: 2,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 150,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [0, 1],
              walk: [1, 1],
              shoot: [2, .6],
              reload: [3, .7],
              reload_full: [4, .7]
            },
            damage: 5,
            headshotDamage: 10,
            reloadDelay: null
          },
          "FN-502": {
            name: "FN-502",
            ammoCapacity: 10,
            ammoCurrent: 10,
            ammoType: "pistol",
            magazineCurrent: 2,
            magazineCapacity: 2,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 100,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [1, .1],
              walk: [0, 1],
              shoot: [2, 1],
              reload: [3, 1],
              reload_full: [4, 1]
            },
            damage: 10,
            headshotDamage: 15,
            reloadDelay: null
          },
          "Desert-Eagle": {
            name: "Desert-Eagle",
            ammoCapacity: 7,
            ammoCurrent: 7,
            ammoType: "pistol",
            magazineCurrent: 2,
            magazineCapacity: 2,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 400,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [1, .1],
              walk: [0, .8],
              shoot: [2, 1],
              reload: [3, .7],
              reload_full: [4, .7]
            },
            triggerDelay: 150,
            damage: 30,
            headshotDamage: 50,
            reloadDelay: null,
            muzzleFlash: {
              enabled: true,
              x: 0.2,
              y: -0.05,
              z: -1.5
            }
          },
          "Railgun": {
            name: "Railgun",
            ammoCapacity: 1,
            ammoCurrent: 1,
            ammoType: "railgun",
            magazineCurrent: 3,
            magazineCapacity: 3,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 3000,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [0, 1],
              walk: [1, .6],
              shoot: [2, .6],
              reload: [3, .5],
              reload_full: [3, .5]
            },
            damage: 100,
            headshotDamage: 100,
            reloadDelay: 400
          },
          "Precision-Railgun": {
            name: "Precision-Railgun",
            ammoCapacity: 4,
            ammoCurrent: 4,
            ammoType: "railgun",
            magazineCurrent: 2,
            magazineCapacity: 2,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 3000,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [0, 1],
              walk: [1, .5],
              shoot: [2, .6],
              reload: [3, .4],
              reload_full: [3, .4]
            },
            damage: 100,
            headshotDamage: 100,
            reloadDelay: 400
          },
          "HK-G28": {
            name: "HK-G28",
            ammoCapacity: 10,
            ammoCurrent: 10,
            ammoType: "sniper",
            magazineCurrent: 3,
            magazineCapacity: 3,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 1500,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [3, 1],
              walk: [2, 1],
              shoot: [0, 1],
              reload: [4, 1],
              reload_full: [5, 1]
            },
            triggerDelay: 1300,
            damage: 45,
            headshotDamage: 100,
            reloadDelay: null,
            muzzleFlash: {
              enabled: true,
              x: 0.25,
              y: -0.15,
              z: -2
            }
          },
          "AWP-L96": {
            name: "AWP-L96",
            ammoCapacity: 5,
            ammoCurrent: 5,
            ammoType: "sniper",
            magazineCurrent: 2,
            magazineCapacity: 2,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 1500,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [3, 1],
              walk: [2, 1],
              shoot: [0, 1],
              reload: [4, 1],
              reload_full: [5, 1]
            },
            triggerDelay: 1300,
            damage: 70,
            headshotDamage: 100,
            reloadDelay: 550
          },
          "M40a3": {
            name: "M40a3",
            ammoCapacity: 4,
            ammoCurrent: 4,
            ammoType: "sniper",
            magazineCurrent: 1,
            magazineCapacity: 1,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 1500,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [3, 1],
              walk: [2, 1],
              shoot: [0, 1],
              reload: [4, 1],
              reload_full: [5, 1]
            },
            triggerDelay: 1300,
            damage: 35,
            headshotDamage: 100,
            reloadDelay: null
          },
          "Barrett-50cal": {
            name: "Barrett-50cal",
            ammoCapacity: 2,
            ammoCurrent: 2,
            ammoType: "sniper",
            magazineCurrent: 1,
            magazineCapacity: 1,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 2000,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [3, 1],
              walk: [2, .6],
              shoot: [0, .8],
              reload: [4, 1],
              reload_full: [5, 1]
            },
            triggerDelay: 1500,
            damage: 100,
            headshotDamage: 100,
            reloadDelay: null,
            muzzleFlash: {
              enabled: true,
              x: 0,
              y: -0.05,
              z: -1.5
            }
          },
          "Remington-870": {
            name: "Remington-870",
            ammoCapacity: 4,
            ammoCurrent: 4,
            ammoType: "shotgun",
            magazineCurrent: 1,
            magazineCapacity: 1,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 700,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [0, 1],
              walk: [1, 1],
              shoot: [2, 1],
              reload: [3, 1],
              reload_full: [3, 1]
            },
            triggerDelay: 800,
            damage: 15,
            headshotDamage: 20,
            reloadDelay: null,
            muzzleFlash: {
              enabled: true,
              x: 0.05,
              y: 0,
              z: -1.5
            }
          },
          "Keltec-KSG": {
            name: "Keltec-KSG",
            ammoCapacity: 15,
            ammoCurrent: 15,
            ammoType: "shotgun",
            magazineCurrent: 1,
            magazineCapacity: 1,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 1000,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [0, 1],
              walk: [1, 1],
              shoot: [2, .2],
              reload: [3, 1],
              reload_full: [3, 1]
            },
            damage: 10,
            headshotDamage: 30,
            reloadDelay: null
          },
          "Drum-Shotgun": {
            name: "Drum-Shotgun",
            ammoCapacity: 24,
            ammoCurrent: 24,
            ammoType: "shotgun",
            magazineCurrent: 1,
            magazineCapacity: 1,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 800,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [0, 1],
              walk: [1, 1],
              shoot: [2, .3],
              reload: [3, .6],
              reload_full: [3, .6]
            },
            damage: 7,
            headshotDamage: 9,
            reloadDelay: null
          },
          "Grenade-Launcher": {
            name: "Grenade-Launcher",
            ammoCapacity: 1,
            ammoCurrent: 1,
            ammoType: "grenade",
            magazineCurrent: 1,
            magazineCapacity: 1,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 1000,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [0, 1],
              walk: [1, 1],
              shoot: [2, 1],
              reload: [3, 1],
              reload_full: [3, 1]
            },
            damage: 100,
            headshotDamage: 100,
            reloadDelay: 500
          },
          "Rocket-Launcher": {
            name: "Rocket-Launcher",
            ammoCapacity: 2,
            ammoCurrent: 2,
            ammoType: "rocket",
            magazineCurrent: 1,
            magazineCapacity: 1,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 1000,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [0, 1],
              walk: [1, 1],
              shoot: [2, 1],
              reload: [3, .3],
              reload_full: [3, .3]
            },
            triggerDelay: 600,
            damage: 100,
            headshotDamage: 100,
            reloadDelay: 800,
            zoomingDisabled: true
          },
          "RPG-7": {
            name: "RPG-7",
            ammoCapacity: 1,
            ammoCurrent: 1,
            ammoType: "rocket",
            magazineCurrent: 2,
            magazineCapacity: 2,
            firingModes: ["semi"],
            currentFiringMode: "semi",
            fireRates: {
              "semi": 1000,
              "full": 0,
              "burst": 0
            },
            animationStructure: {
              idle: [0, 1],
              walk: [1, 1],
              shoot: [2, 1],
              reload: [3, .3],
              reload_full: [3, .3]
            },
            damage: 100,
            headshotDamage: 100,
            reloadDelay: 1000
          },
          "M60": {
            name: "M60",
            ammoCapacity: 100,
            ammoCurrent: 100,
            ammoType: "rifle",
            magazineCurrent: 1,
            magazineCapacity: 1,
            firingModes: ["full"],
            currentFiringMode: "full",
            fireRates: {
              "semi": 0,
              "full": 100,
              "burst": 0
            },
            animationStructure: {
              idle: [0, 1],
              walk: [1, 1],
              shoot: [2, 1],
              reload: [3, .5],
              reload_full: [4, .5]
            },
            damage: 5,
            headshotDamage: 10,
            reloadDelay: null,
            muzzleFlash: {
              enabled: true,
              x: 0.1,
              y: -0.05,
              z: -2
            }
          },
        },
        grenades: {
          current: 2,
          capacity: 2
        },
        respawnPoints: {
          "Cargo_Port": [[13.5,0,-18.5,0,3.141592653589793,0],[7.6,0,-18.3,0,1.5707963267948966,0],[-8.9,0,-16,0,-1.5707963267948966,0],[17.5,0,-9.6,0,1.5707963267948966,0],[16.9,0,-2.2,0,1.5707963267948966,0],[10,0,1.2,0,6.283185307179586,0],[20,0,5.2,0,6.283185307179586,0],[17.1,0,14.6,0,6.283185307179586,0],[6.9,0,16.5,0,1.5707963267948966,0],[-5,0,-9.3,0,3.141592653589793,0],[-9.1,0,2.7,0,-1.5707963267948966,0],[8,0,3.2,0,3.141592653589793,0]],
          "Ghost_Town": [[15,0,-1.7,0,0,0],[15.6,0,-15,0,3.141592653589793,0],[11.8,0,-7.4,0,-1.5707963267948966,0],[30.8,0.2,-11,0,3.141592653589793,0],[27.7,0,-19,0,3.141592653589793,0],[28.4,-1,26,0,0,0],[44.6,-1,29.7,0,0,0],[55.1,0,-4.9,0,1.5707963267948966,0],[68.6,0,-9.7,0,1.5707963267948966,0]],
          "Abandoned_City": [[-8.8,0,-31.4,0,-1.5707963267948966,0],[-20.8,0,-29.7,0,-1.5707963267948966,0],[-32.7,-0.09999999999999998,-23.3,0,-1.5707963267948966,0],[-10.8,0,12.7,0,0,0],[3.3,0,-0.2,0,-1.5707963267948966,0],[-13.6,0,-6.5,0,0,0],[9.5,0,-29.4,0,-1.5707963267948966,0],[-15.4,0,-44.4,0,3.141592653589793,0],[-25.3,0,-26.1,0,1.5707963267948966,0],[8.2,0,-13.2,0,-1.5707963267948966,0],[20.6,0,-11.7,0,3.141592653589793,0],[32.2,0,0.5,0,1.5707963267948966,0],[-32.1,-0.09999999999999998,2.6,0,3.141592653589793,0]],
          "Lihid": [[15.7,-0.19999999999999996,-17.5,0,3.141592653589793,0],[15.5,0.19999999999999996,-25.3,0,3.141592653589793,0],[4.9,-0.19999999999999996,-20.3,0,-1.5707963267948966,0],[5.9,-1.5,-6.1,0,1.5707963267948966,0],[-4.2,-3.2,-3,0,1.5707963267948966,0],[-14.9,-3,-4,0,-1.5707963267948966,0],[-28.5,-1.1,-1.3,0,-1.5707963267948966,0],[-22.5,-1.5,-7.5,0,0,0],[-19.7,-1.5,-21.8,0,1.5707963267948966,0],[-25.9,-1.1,-24.3,0,3.141592653589793,0],[-5.8,-3.1,-17.1,0,3.141592653589793,0],[3,-3.2,-17.4,0,3.141592653589793,0],[23,-0.8,-12.1,0,1.5707963267948966,0],[22.6,-0.6,7.4,0,1.5707963267948966,0],[13.6,-1.5,-0.2,0,3.141592653589793,0],[8,-1.5,2.2,0,-1.5707963267948966,0],[8.9,-1.5,7.6,0,1.5707963267948966,0],[-20.9,0.19999999999999996,17.8,0,3.141592653589793,0],[-20.9,0.19999999999999996,26.6,0,0,0],[-28.6,0.19999999999999996,22.9,0,-1.5707963267948966,0],[-19.9,-1.1,5.8,0,3.141592653589793,0]],
          "Breakthrough": [[5.2,0,6.3,0,0,0],[13.8,0,6.2,0,0,0],[18.9,0,0.3,0,1.5707963267948966,0],[10,2.1,5.9,0,0,0],[14.9,2.1,6.2,0,0,0],[13.1,2,-7.9,0,0,0],[6.8,1.7999999999999998,-8.2,0,3.141592653589793,0],[8.9,0,-23.3,0,-1.5707963267948966,0],[5.3,0,-22.4,0,3.141592653589793,0],[10,0.10000000000000009,-14.9,0,1.5707963267948966,0],[5.1,0,-9.6,0,0,0],[8.5,0,-8.9,0,-1.5707963267948966,0],[18.3,0,-8.8,0,1.5707963267948966,0],[12.1,0,-8.1,0,3.141592653589793,0],[11.9,0,0.9,0,3.141592653589793,0]]
        },
        defaultLoadout: user.preferences.game.loadout,
        loadout: []
      };

      if (params().map) {
        sandbox.map = params().map;
      } else {
        // This is the default map
        sandbox.map = "Cargo_Port";
      }
      window.LoadingManager.setMapPreview(sandbox.map);

      utils = {
        loadingManager: new THREE.LoadingManager(),
        precompileShaders: function(object) {
          scene.add(object);
          object.position.set(0, -1000, 0);
          renderer.compile(scene, camera);
          scene.remove(object);
        },
        json: {
          copy: function(object) {
            return JSON.parse(JSON.stringify(object));
          }
        },
        cache: {
          options: {},
          models: {},
          library: {},
          publish: function(book) {
            utils.cache.library[book] = {};
          },
          write: function(book, page, value) {
            utils.cache.library[book][page] = value;
          },
          read: function(book, page) {
            let value = utils.cache.library[book][page];
            if (typeof value === "undefined") value = null;
            return value;
          }
        },
        options: {
          set: function(key, value) {
            utils.cache.options[key] = value;
          },
          get: function(key) {
            return utils.cache.options[key];
          },
          defineWeapon: function(options = {}) {
            sandbox.weapons.push(options);
          }
        },
        scoreboard: {
          teams: {},
          add: function(team, increment = 1) {
            utils.scoreboard.teams[team].score += increment;
            utils.scoreboard.update();
          },
          update: function() {
            let scoreboard1 = document.querySelector(".ui .scoreboard .scoreboard-marker-1");
            let scoreboard2 = document.querySelector(".ui .scoreboard .scoreboard-marker-2");

            let topTeam = null;
            let currentTeam = utils.scoreboard.teams[sandbox.username];
            for (i in utils.scoreboard.teams) {
              let team = utils.scoreboard.teams[i];
              if (topTeam === null ? (team.name !== sandbox.username) : (team.score >= topTeam.score && team.name !== sandbox.username)) topTeam = team;
            }

            if (!topTeam) return;

            let topTeamName = topTeam.name.slice(0, 5) !== topTeam.name ? topTeam.name.slice(0, 5) + "..." : topTeam.name;
            let currentTeamName = "You";
            if (topTeam.score >= currentTeam.score) {
              scoreboard1.querySelector("#value").textContent = topTeam.score;
              scoreboard1.querySelector(".scoreboard-team").textContent = topTeamName;

              scoreboard2.querySelector("#value").textContent = currentTeam.score;
              scoreboard2.querySelector(".scoreboard-team").textContent = currentTeamName;
            } else {
              scoreboard2.querySelector("#value").textContent = topTeam.score;
              scoreboard2.querySelector(".scoreboard-team").textContent = topTeamName;

              scoreboard1.querySelector("#value").textContent = currentTeam.score;
              scoreboard1.querySelector(".scoreboard-team").textContent = currentTeamName;
            }

            if (topTeam.score >= sandbox.presets.scoreLimit || currentTeam.score >= sandbox.presets.scoreLimit) {
              gameEnd();
            }
          },
          topTeam: function() {
            let highestScore = Math.max(...Object.values(utils.scoreboard.teams).map(team => team.score));
            let topTeams = Object.entries(utils.scoreboard.teams).filter(([d, team]) => team.score === highestScore).map(([name, d]) => name);
            return topTeams;
          },
          addTeam: function(teamName) {
            utils.scoreboard.teams[teamName] = {
              name: teamName,
              score: 0
            };
            utils.scoreboard.update();
          }
        },
        weapons: {
          getMetadata: function(weapon) {
            let alias = sandbox.weapons[weapon];
            let metadata = {
              name: weapon,
              ammo: alias.ammoCurrent,
              magazines: alias.magazineCurrent
            };

            return metadata;
          },
          playAnimation: function(animation, callback = () => {}, options) {
            let currentWeapon = sandbox.models[`weapon_${sandbox.primaryWeapon == sandbox.currentWeapon ? sandbox.loadout[0] : sandbox.loadout[1]}`];
            let clip = null;
            if (animation === "idle") {
              let animationIndex = sandbox.currentWeapon.alias.animationStructure["idle"][0];
              let animationTimeScale = sandbox.currentWeapon.alias.animationStructure["idle"][1];
              clip = currentWeapon.mixer.clipAction(currentWeapon.animations[animationIndex]);
              clip.timeScale = animationTimeScale;
              clip.loop = THREE.LoopRepeat;
              clip.reset();
              clip.play();
            }
            if (animation === "walk") {
              let animationIndex = sandbox.currentWeapon.alias.animationStructure["walk"][0];
              let animationTimeScale = sandbox.currentWeapon.alias.animationStructure["walk"][1];
              clip = currentWeapon.mixer.clipAction(currentWeapon.animations[animationIndex]);
              clip.timeScale = animationTimeScale;
              clip.loop = THREE.LoopPingPong;
              clip.reset();
              clip.play();
            }
            if (animation === "reload") {
              let animationIndex = sandbox.currentWeapon.alias.animationStructure["reload"][0];
              let animationTimeScale = sandbox.currentWeapon.alias.animationStructure["reload"][1];
              clip = currentWeapon.mixer.clipAction(currentWeapon.animations[animationIndex]);
              clip.timeScale = animationTimeScale;
              clip.loop = THREE.LoopOnce;
              clip.reset();
              if (options) {
                if (options.startTime) clip.time = options.startTime;
                if (options.fadeIn) clip.fadeIn(options.fadeIn);
              }
              clip.play();
            }
            if (animation === "full-reload") {
              let animationIndex = sandbox.currentWeapon.alias.animationStructure["reload_full"][0];
              let animationTimeScale = sandbox.currentWeapon.alias.animationStructure["reload_full"][1];
              clip = currentWeapon.mixer.clipAction(currentWeapon.animations[animationIndex]);
              clip.timeScale = animationTimeScale;
              clip.loop = THREE.LoopOnce;
              clip.reset();
              clip.play();
            }
            if (animation === "shoot") {
              let animationIndex = sandbox.currentWeapon.alias.animationStructure["shoot"][0];
              let animationTimeScale = sandbox.currentWeapon.alias.animationStructure["shoot"][1];
              clip = currentWeapon.mixer.clipAction(currentWeapon.animations[animationIndex]);
              clip.timeScale = animationTimeScale;
              clip.loop = THREE.LoopOnce;
              clip.reset();
              clip.play();
            }
            if (animation === "run") {
              utils.cache.read("garbage", "runStopTween").stop();
              utils.cache.write("garbage", "runTween", new TWEEN.Tween(sandbox.currentWeapon.children[0].rotation).to({ x: 0.2, y: 0.2, z: 0 }, 1000).easing(TWEEN.Easing.Quadratic.InOut).start());
              return;
            }

            let finished = false;
            let customCallback = function(event) {
              if (event.action === clip) {
                if (finished) return;
                finished = true;
                callback();
              }
            };
            currentWeapon.mixer.addEventListener("finished", customCallback);

            return clip;
          },
          stopAnimation: function(animation, options = {}) {
            let currentWeapon = sandbox.models[`weapon_${sandbox.primaryWeapon == sandbox.currentWeapon ? sandbox.loadout[0] : sandbox.loadout[1]}`];
            let clip = null;
            if (animation === "idle") {
              let animationIndex = sandbox.currentWeapon.alias.animationStructure["idle"][0];
              clip = currentWeapon.mixer.clipAction(currentWeapon.animations[animationIndex]);
              clip.stop();
              clip.reset();
            }
            if (animation === "walk") {
              let animationIndex = sandbox.currentWeapon.alias.animationStructure["walk"][0];
              clip = currentWeapon.mixer.clipAction(currentWeapon.animations[animationIndex]);
              clip.fadeOut(options.instant ? 0 : 1);
            }
            if (animation === "shoot") {
              let animationIndex = sandbox.currentWeapon.alias.animationStructure["shoot"][0];
              clip = currentWeapon.mixer.clipAction(currentWeapon.animations[animationIndex]);
              clip.stop();
              clip.reset();
            }
            if (animation === "reload") {
              let animationIndex = sandbox.currentWeapon.alias.animationStructure["reload"][0];
              clip = currentWeapon.mixer.clipAction(currentWeapon.animations[animationIndex]);
              clip.stop();
              clip.reset();
            }
            if (animation === "full-reload") {
              let animationIndex = sandbox.currentWeapon.alias.animationStructure["reload_full"][0];
              clip = currentWeapon.mixer.clipAction(currentWeapon.animations[animationIndex]);
              clip.stop();
              clip.reset();
            }
            if (animation === "run") {
              if (options.instant) {
                sandbox.currentWeapon.children[0].rotation.set(0, 0, 0);
              } else {
                utils.cache.write("garbage", "runStopTween", new TWEEN.Tween(sandbox.currentWeapon.children[0].rotation).to({ x: 0, y: 0, z: 0 }, 600).easing(TWEEN.Easing.Quadratic.InOut).start());
              }
              utils.cache.read("garbage", "runTween").stop();
              return;
            }

            currentWeapon.mixer.dispatchEvent({ type: "finished", action: clip });
          },
          updatePosition: function() {
            if (sandbox.models[`weapon_${sandbox.loadout[0]}`].loaded/* && sandbox.models[`weapon_${sandbox.loadout[1]}`].loaded*/) {
              sandbox.currentWeapon.position.copy(weaponCamera.position);
              sandbox.currentWeapon.rotation.copy(weaponCamera.rotation);
              sandbox.currentWeapon.rotateY(Math.PI);
              sandbox.currentWeapon.rotateZ(.05);
              sandbox.currentWeapon.translateX(-.2);
              sandbox.currentWeapon.translateY(-.45);
              sandbox.currentWeapon.translateZ(.1);
            }
          },
          zoom: async function(reloading = false) {
            if (utils.options.get("Reloading") && !reloading) return;
            if (utils.options.get("Running")) return utils.weapons.cancelRun();
            if (utils.options.get("Melee")) return;
            if (sandbox.currentWeapon.alias.zoomingDisabled) return;
            utils.options.set("Zooming", true);

            utils.camera.stopShake();
            THREE.Sound.stop("preloaded:zooming_scope_in");
            THREE.Sound.stop("preloaded:zooming_precision_in");
            THREE.Sound.stop("preloaded:zooming_scope_out");
            THREE.Sound.stop("preloaded:zooming_precision_out");

            if (utils.options.get("Zoomed")) {
              utils.options.set("Zoomed", false);

              utils.cache.read("garbage", "zoomInPositionTween").stop();
              utils.cache.read("garbage", "zoomInRotationTween").stop();
              utils.cache.read("garbage", "zoomInCameraTween").stop();
              utils.cache.read("garbage", "zoomInWeaponCameraTween").stop();

              if (utils.options.get("Walking")) {
                utils.camera.shake(0.2, 200, true);
              }

              document.querySelector(".crosshair").style.visibility = "";
              let currentWeapon = sandbox.models[`weapon_${sandbox.primaryWeapon == sandbox.currentWeapon ? sandbox.loadout[0] : sandbox.loadout[1]}`];
              if (sandbox.currentWeapon.alias.ammoType === "sniper" || sandbox.currentWeapon.alias.ammoType === "railgun") {
                THREE.Sound("preloaded:zooming_scope_out", false);
              } else if (sandbox.currentWeapon.alias.ammoType === "rifle" || sandbox.currentWeapon.alias.ammoType === "pistol" || sandbox.currentWeapon.alias.ammoType === "shotgun" || sandbox.currentWeapon.alias.ammoType === "rocket" || sandbox.currentWeapon.alias.ammoType === "grenade") {
                THREE.Sound("preloaded:zooming_precision_out", false);
              }
              if (currentWeapon.model.children[0].userData.zoomType === "real") {
                let zoomRotation = currentWeapon.model.children[0].userData.zoomRotation;

                // Transition the zoom out
                const startFOV = camera.fov;
                const endFOV = 60;
                const duration = currentWeapon.model.children[0].userData.zoomDuration[1];
                utils.cache.write("garbage", "zoomOutPositionTween", new TWEEN.Tween(currentWeapon.model.children[0].position).to({ x: 0, y: 0, z: 0 }, duration).easing(TWEEN.Easing.Quadratic.InOut).start());
                utils.cache.write("garbage", "zoomOutRotationTween", new TWEEN.Tween(currentWeapon.model.children[0].rotation).to({ x: 0, y: 0, z: 0 }, duration).easing(TWEEN.Easing.Quadratic.InOut).start());

                utils.cache.write("garbage", "zoomOutCameraTween", new TWEEN.Tween(camera).to({ fov: endFOV }, duration).easing(TWEEN.Easing.Quadratic.InOut).onUpdate(() => { camera.updateProjectionMatrix() }).start());
                utils.cache.write("garbage", "zoomOutWeaponCameraTween", new TWEEN.Tween(weaponCamera).to({ fov: endFOV }, duration).easing(TWEEN.Easing.Quadratic.InOut).onUpdate(() => { weaponCamera.updateProjectionMatrix() }).start());

                plugins.realTimeout(() => {
                  utils.options.set("Zooming", false);
                }, duration);

                return duration;
              }
            } else {
              utils.options.set("Zoomed", true);
              document.querySelector(".crosshair").style.visibility = "hidden";

              utils.cache.read("garbage", "zoomOutPositionTween").stop();
              utils.cache.read("garbage", "zoomOutRotationTween").stop();
              utils.cache.read("garbage", "zoomOutCameraTween").stop();
              utils.cache.read("garbage", "zoomOutWeaponCameraTween").stop();

              let currentWeapon = sandbox.models[`weapon_${sandbox.primaryWeapon == sandbox.currentWeapon ? sandbox.loadout[0] : sandbox.loadout[1]}`];
              if (sandbox.currentWeapon.alias.ammoType === "sniper" || sandbox.currentWeapon.alias.ammoType === "railgun") {
                THREE.Sound("preloaded:zooming_scope_in", false);
              } else if (sandbox.currentWeapon.alias.ammoType === "rifle" || sandbox.currentWeapon.alias.ammoType === "pistol" || sandbox.currentWeapon.alias.ammoType === "shotgun" || sandbox.currentWeapon.alias.ammoType === "rocket" || sandbox.currentWeapon.alias.ammoType === "grenade") {
                THREE.Sound("preloaded:zooming_precision_in", false);
              }
              if (currentWeapon.model.children[0].userData.zoomType === "real") {
                let zoomPosition = currentWeapon.model.children[0].userData.zoomPosition;
                let zoomRotation = currentWeapon.model.children[0].userData.zoomRotation;

                // Transition the zoom in
                const startFOV = camera.fov;
                const endFOV = currentWeapon.model.children[0].userData.zoomFov;
                const duration = currentWeapon.model.children[0].userData.zoomDuration[0];
                utils.cache.write("garbage", "zoomInPositionTween", new TWEEN.Tween(currentWeapon.model.children[0].position).to({ x: zoomPosition.x, y: zoomPosition.y, z: zoomPosition.z }, duration).easing(TWEEN.Easing.Quadratic.InOut).start());
                utils.cache.write("garbage", "zoomInRotationTween", new TWEEN.Tween(currentWeapon.model.children[0].rotation).to({ x: zoomRotation.x, y: zoomRotation.y, z: zoomRotation.z }, duration).easing(TWEEN.Easing.Quadratic.InOut).start());

                utils.cache.write("garbage", "zoomInCameraTween", new TWEEN.Tween(camera).to({ fov: endFOV }, duration).easing(TWEEN.Easing.Quadratic.InOut).onUpdate(() => { camera.updateProjectionMatrix() }).start());
                utils.cache.write("garbage", "zoomInWeaponCameraTween", new TWEEN.Tween(weaponCamera).to({ fov: endFOV }, duration).easing(TWEEN.Easing.Quadratic.InOut).onUpdate(() => { weaponCamera.updateProjectionMatrix() }).start());

                plugins.realTimeout(() => {
                  utils.options.set("Zooming", false);
                }, duration);

                return duration;
              }
            }
          },
          shoot: function(repeat = false, shots = 1, timing = 100) {
            if (utils.options.get("Running")) return utils.weapons.cancelRun();
            if (utils.options.get("Zooming")) return;
            if (utils.options.get("Melee")) return;
            if (sandbox.currentWeapon.alias.ammoCurrent <= 0) return;
            if (utils.options.get("Reloading") || utils.options.get("TriggerCooldown")) return;
            if (sandbox.currentWeapon.alias.currentFiringMode == "semi" || sandbox.currentWeapon.alias.currentFiringMode == "burst") {
              if (sandbox.currentWeapon.alias.triggerDelay) {
                utils.options.set("TriggerCooldown", true);
                plugins.delay(sandbox.currentWeapon.alias.triggerDelay).then(function() {
                  utils.options.set("TriggerCooldown", false);
                });
              }
            }

            utils.options.set("Shooting", true);
            utils.weapons.stopAnimation("walk", { instant: true });
            let reloadDelay = sandbox.currentWeapon.alias.reloadDelay;
            if (sandbox.currentWeapon.alias.ammoCapacity === 1 && reloadDelay === null) reloadDelay = 200;
            let fireDelay = sandbox.currentWeapon.alias.fireRates[sandbox.currentWeapon.alias.currentFiringMode];
            if (fireDelay) timing = fireDelay;
            let shotCount = 0;
            let shotDelay = 0;
            let sound = true;
            let bulletSpread = 0.05;
            function next(playEffects = true) {
              let shotIteration;
              shotIteration = plugins.noDelayInterval(() => {
                if (utils.options.get("StopShooting") && shots == Infinity) return utils.options.set("StopShooting", false), clearInterval(shotIteration);
                if (shotCount >= shots) return clearInterval(shotIteration);
                shotCount++;

                let weaponData = sandbox.currentWeapon.children[0].userData;
                if (playEffects) {
                  sandbox.currentWeapon.alias.ammoCurrent--;
                  utils.weapons.playAnimation("shoot");
                }

                let randomSpread = { x: (Math.random() - 0.5) * bulletSpread, y: (Math.random() - 0.5) * bulletSpread };

                if (utils.options.get("Zoomed")) {
                  randomSpread.x /= 3;
                  randomSpread.y /= 3;
                }

                utils.weapons.effects.bulletHole(randomSpread);
                utils.weapons.effects.bulletSpark(randomSpread);

                if (sandbox.currentWeapon.children[0].userData.leftRightSwitching) {
                  sandbox.currentWeapon.getObjectByName("ObjectHolder_LeftHand").visible = true;
                  sandbox.currentWeapon.getObjectByName("ObjectHolder_RightHand").visible = false;
                }

                if (sandbox.currentWeapon.children[0].userData.boltMoves) {
                  let bolt = sandbox.currentWeapon.getObjectByName(sandbox.currentWeapon.children[0].userData.boltObject);
                  let boltLength = sandbox.currentWeapon.children[0].userData.boltLength;
                  new TWEEN.Tween(bolt.position).to({ x: 0, y: 0, z: -boltLength }, timing / 4).easing(TWEEN.Easing.Quadratic.InOut).start();
                  setTimeout(() => {
                    new TWEEN.Tween(bolt.position).to({ x: 0, y: 0, z: 0 }, timing / 4).easing(TWEEN.Easing.Quadratic.InOut).start();
                  }, (timing / 4) + 10);
                }
                if (sound && playEffects) {
                  gametime.run("weaponEffectShoot", [gametime.player.uuid, sandbox.currentWeapon.alias.name]);
                  THREE.Sound(`preloaded:shooting_${sandbox.currentWeapon.alias.name}`, false);
                  if (utils.options.get("Zoomed")) {
                    utils.camera.shake(0.5, 100, false, camera.fov);
                  } else {
                    if (sandbox.currentWeapon.alias.muzzleFlash && sandbox.currentWeapon.alias.muzzleFlash.enabled) {
                      let flash = utils.cache.read("garbage", "muzzleFlash");
                      let muzzleData = sandbox.currentWeapon.alias.muzzleFlash;

                      flash.position.copy(camera.position);
                      flash.rotation.copy(camera.rotation);
                      flash.rotation.order = "YXZ";

                      flash.translateX(muzzleData.x);
                      flash.translateY(muzzleData.y);
                      flash.translateZ(muzzleData.z);

                      flash.visible = true;
                      setTimeout(() => {
                        flash.visible = false;

                        flash = null;
                        muzzleData = null;
                      }, 10);
                    }
                  }
                }

                utils.weapons.update();
                if (utils.options.get("Walking")) utils.weapons.playAnimation("walk");
                utils.options.set("Shooting", false);
                if (sandbox.currentWeapon.alias.ammoCurrent < 1) return utils.weapons.reload(true, reloadDelay), clearInterval(shotIteration);
              }, timing);
            }
            if (sandbox.currentWeapon.alias.ammoType === "railgun") {
              if (!repeat) {
                sound = false;
                let shotRailgun = false;
                THREE.Sound(`preloaded:shooting_${sandbox.currentWeapon.alias.name}`, false);
                let triggerChecker = setInterval(() => {
                  if (!shootRapid) {
                    clearTimeout(shotDelay);
                    clearInterval(triggerChecker);
                    if (!shotRailgun) THREE.Sound.stop(`preloaded:shooting_${sandbox.currentWeapon.alias.name}`);
                  }
                });
                shots = sandbox.currentWeapon.alias.ammoCapacity;
                shotDelay = setTimeout(() => (next(), shotRailgun = true, clearInterval(triggerChecker)), 500);
              }
            } else if (sandbox.currentWeapon.alias.ammoType === "grenade") {
              if (!repeat) {
                utils.weapons.grenades.throw(false, false);
                sandbox.currentWeapon.alias.ammoCurrent--;
                utils.weapons.playAnimation("shoot");
                gametime.run("weaponEffectShoot", [gametime.player.uuid, sandbox.currentWeapon.alias.name]);
                THREE.Sound(`preloaded:shooting_${sandbox.currentWeapon.alias.name}`, false);
                utils.weapons.update();
                if (sandbox.currentWeapon.alias.ammoCurrent < 1) return utils.weapons.reload(true, reloadDelay);
              }
            } else {
              if (repeat) return;
              utils.options.set("StopShooting", false);
              if (sandbox.currentWeapon.alias.currentFiringMode === "semi") {
                if (sandbox.currentWeapon.alias.ammoType === "shotgun") {
                  for (let i = 0; i < 8; i++) {
                    shotCount = 0;
                    next(i == 0);
                  }
                } else {
                  next();
                }
              } else if (sandbox.currentWeapon.alias.currentFiringMode === "full") {
                shots = Infinity;
                next();
              } else if (sandbox.currentWeapon.alias.currentFiringMode === "burst") {
                shots = 3;
                next();
              }
            }
          },
          stopShoot: function() {
            utils.options.set("StopShooting", true);
          },
          reload: async function(full, reloadDelay = null) {
            if (utils.options.get("Running")) utils.weapons.cancelRun();
            if (utils.options.get("Melee")) return;
            if (sandbox.currentWeapon.alias.ammoCurrent >= sandbox.currentWeapon.alias.ammoCapacity) return;
            if (sandbox.currentWeapon.alias.magazineCurrent <= 0) return;
            if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);
            if (utils.options.get("Reloading")) return;
            utils.options.set("Reloading", true);

            if (reloadDelay) await plugins.realDelay(reloadDelay);
            if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);

            if (sandbox.currentWeapon.alias.ammoType === "rocket") {
              utils.cache.write("garbage", "rocketReloadPositionTween", new TWEEN.Tween(sandbox.currentWeapon.children[0].position).to({ y: -0.2 }, 500).easing(TWEEN.Easing.Quadratic.InOut).start());
              utils.cache.write("garbage", "rocketReloadRotationTween", new TWEEN.Tween(sandbox.currentWeapon.children[0].rotation).to({ x: 0.5 }, 500).easing(TWEEN.Easing.Quadratic.InOut).start());
            }

            // Stop the other animations temporarily
            utils.weapons.stopAnimation("idle");
            utils.weapons.stopAnimation("shoot");
            utils.weapons.stopAnimation("walk", { instant: true });

            // If the gun is zoomed in, automatically zoom out
            if (utils.options.get("Zoomed")) utils.weapons.zoom(true);

            // Stop ongoing shooting sound effects
            if (reloadDelay && sandbox.currentWeapon.ammoType !== "railgun") THREE.Sound.stop(`preloaded:shooting_${sandbox.currentWeapon.alias.name}`);

            if (sandbox.currentWeapon.children[0].userData.leftRightSwitching) {
              sandbox.currentWeapon.getObjectByName("ObjectHolder_LeftHand").visible = true;
              sandbox.currentWeapon.getObjectByName("ObjectHolder_RightHand").visible = false;
            }

            // Play the reload animation and sound
            if (sandbox.currentWeapon.children[0].userData.magMovesOnReload) {
              if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);
              (async () => {
                let magazine = sandbox.currentWeapon.getObjectByName(sandbox.currentWeapon.children[0].userData.magObject);
                if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);
                await plugins.realDelay(sandbox.currentWeapon.children[0].userData.magMoveTimeStart);
                if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);
                new TWEEN.Tween(magazine.position).to({ x: 0, y: -10, z: 0 }, 500).easing(TWEEN.Easing.Quadratic.InOut).start();
                await plugins.realDelay(sandbox.currentWeapon.children[0].userData.magMoveTimeEnd);
                if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);
                magazine.position.y = 0;
              })();
              if (sandbox.currentWeapon.children[0].userData.leftRightSwitching && sandbox.currentWeapon.children[0].userData.leftRightSwitchingMag) {
                (async () => {
                  let magazine = sandbox.currentWeapon.getObjectByName(sandbox.currentWeapon.children[0].userData.leftRightSwitchingMag);
                  if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);
                  await plugins.realDelay(sandbox.currentWeapon.children[0].userData.magMoveTimeStart);
                  if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);
                  new TWEEN.Tween(magazine.position).to({ x: 0, y: -10, z: 0 }, 500).easing(TWEEN.Easing.Quadratic.InOut).start();
                  await plugins.realDelay(sandbox.currentWeapon.children[0].userData.magMoveTimeEnd);
                  if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);
                  magazine.position.y = 0;
                })();
              }
            }

            function finish() {
              if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);
              utils.weapons.playAnimation("idle");
              if (sandbox.currentWeapon.children[0].userData.leftRightSwitching) {
                sandbox.currentWeapon.getObjectByName("ObjectHolder_LeftHand").visible = true;
                sandbox.currentWeapon.getObjectByName("ObjectHolder_RightHand").visible = false;
              }
              if (utils.options.get("Walking")) {
                utils.weapons.playAnimation("walk");
                if (!utils.options.get("Zoomed")) utils.camera.shake(0.2, 200, true);
              }

              // Decrement the current magazine count
              sandbox.currentWeapon.alias.magazineCurrent--;

              // Reset the ammo count
              sandbox.currentWeapon.alias.ammoCurrent = sandbox.currentWeapon.alias.ammoCapacity;

              // If this weapon is a rocket launcher, we'll return the rocket projectile if necessary
              if (sandbox.currentWeapon.alias.ammoType === "rocket") {
                if (sandbox.currentWeapon.children[0].userData.rocketProjectile) {
                  sandbox.currentWeapon.children[0].add(scene.getObjectByName(sandbox.currentWeapon.children[0].userData.rocketProjectileHolder));
                  let bullet = sandbox.currentWeapon.getObjectByName(sandbox.currentWeapon.children[0].userData.rocketProjectile);
                  let holder = sandbox.currentWeapon.getObjectByName(sandbox.currentWeapon.children[0].userData.rocketProjectileHolder);
                  let fakeHolder = sandbox.currentWeapon.getObjectByName(sandbox.currentWeapon.children[0].userData.rocketProjectileHolderFake);
                  let defaultPosition = holder.userData.defaultPosition;
                  bullet.position.z = 0;
                  holder.position.set(defaultPosition.x, defaultPosition.y, defaultPosition.z);
                  holder.rotation.set(0, 0, 0);
                  holder.visible = false;
                  fakeHolder.visible = true;
                }

                new TWEEN.Tween(sandbox.currentWeapon.children[0].position).to({ y: 0 }, 500).easing(TWEEN.Easing.Quadratic.InOut).start();
                new TWEEN.Tween(sandbox.currentWeapon.children[0].rotation).to({ x: 0 }, 500).easing(TWEEN.Easing.Quadratic.InOut).start();
              }

              utils.weapons.update();

              utils.options.set("Reloading", false);
            }

            let animation = null;
            if (sandbox.currentWeapon.alias.ammoType === "grenade") {
              animation = utils.weapons.playAnimation("reload", finish, {
                fadeIn: 0.5,
                startTime: 4
              });
              THREE.Sound(`preloaded:reloading_${sandbox.currentWeapon.alias.name}`, false);
            } else {
              if (full) {
                animation = utils.weapons.playAnimation("full-reload", finish);
                THREE.Sound(`preloaded:reloadingfull_${sandbox.currentWeapon.alias.name}`, false);
              } else {
                animation = utils.weapons.playAnimation("reload", finish);
                THREE.Sound(`preloaded:reloading_${sandbox.currentWeapon.alias.name}`, false);
              }
            }

            if (sandbox.currentWeapon.children[0].userData.boltMoves) {
              setTimeout(() => {
                if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);
                let bolt = sandbox.currentWeapon.getObjectByName(sandbox.currentWeapon.children[0].userData.boltObject);
                let boltLength = sandbox.currentWeapon.children[0].userData.boltLength;
                new TWEEN.Tween(bolt.position).to({ x: 0, y: 0, z: -boltLength }, 100).easing(TWEEN.Easing.Quadratic.InOut).start();
                setTimeout(() => {
                  new TWEEN.Tween(bolt.position).to({ x: 0, y: 0, z: 0 }, 100).easing(TWEEN.Easing.Quadratic.InOut).start();
                }, 100);
              }, (sandbox.currentWeapon.children[0].userData.magMoveTimeStart + sandbox.currentWeapon.children[0].userData.magMoveTimeEnd) + 550);
            }
            if (sandbox.currentWeapon.children[0].userData.leftRightSwitching) {
              if (full) {
                await plugins.waitUntil(() => animation.time >= 1);
                if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);
                sandbox.currentWeapon.getObjectByName("ObjectHolder_RightHand").visible = true;
                sandbox.currentWeapon.getObjectByName("ObjectHolder_LeftHand").visible = false;
                await plugins.waitUntil(() => animation.time >= 3.8);
                if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);
                sandbox.currentWeapon.getObjectByName("ObjectHolder_LeftHand").visible = true;
                sandbox.currentWeapon.getObjectByName("ObjectHolder_RightHand").visible = false;
              } else {
                sandbox.currentWeapon.getObjectByName("ObjectHolder_RightHand").visible = true;
                sandbox.currentWeapon.getObjectByName("ObjectHolder_LeftHand").visible = false;
                await plugins.waitUntil(() => animation.time >= 3.8);
                if (utils.options.get("CancelReload")) return utils.options.set("CancelReload", false);
                sandbox.currentWeapon.getObjectByName("ObjectHolder_LeftHand").visible = true;
                sandbox.currentWeapon.getObjectByName("ObjectHolder_RightHand").visible = false;
              }
            }
          },
          cancelReload: function() {
            utils.options.set("CancelReload", true);
            utils.weapons.playAnimation("idle");
            utils.weapons.stopAnimation("reload");
            utils.weapons.stopAnimation("full-reload");

            if (sandbox.currentWeapon.alias.ammoType === "rocket") {
              utils.cache.read("garbage", "rocketReloadPositionTween").stop();
              utils.cache.read("garbage", "rocketReloadRotationTween").stop();
              sandbox.currentWeapon.children[0].position.y = 0;
              sandbox.currentWeapon.children[0].rotation.x = 0;
            }
            
            utils.options.set("Reloading", false);
          },
          cancelRun: async function(instant = false) {
            if (utils.options.get("CancelingRun")) return;
            utils.options.set("CancelingRun", true);

            GamepadControls.onsprintend();
            keyStates[keyBindings.sprint] = false;
            utils.weapons.stopAnimation("run", { instant: instant });

            THREE.Sound.stop("preloaded:weapon_running", "running");
            utils.camera.stopShake();
            if (utils.options.get("Walking")) {
              THREE.Sound("preloaded:weapon_walking", false, null, () => {}, 0, 0, true, true, "walking");
              if (!utils.options.get("Zoomed")) utils.camera.shake(0.2, 200, true);
            }

            if (!instant) await plugins.realDelay(600);
            utils.options.set("Running", false);

            utils.options.set("CancelingRun", false);
          },
          switch: function(set = null, initial = false, pickingUp = false) {
            if (utils.options.get("Running")) return utils.weapons.cancelRun();
            if (utils.options.get("Reloading")) {
              utils.weapons.cancelReload();
              if (utils.options.get("Walking")) utils.weapons.playAnimation("walk");
              THREE.Sound.stop(`preloaded:reloading_${sandbox.currentWeapon.alias.name}`);
              THREE.Sound.stop(`preloaded:reloadingfull_${sandbox.currentWeapon.alias.name}`);
            }
            if (utils.options.get("Zoomed")) utils.weapons.zoom(true);
            if (set == null) set = utils.weapons.getCurrent(true);
            if (set == "primary") {
              if (!pickingUp) THREE.Sound("preloaded:weapon_switch_primary", false);

              // Remove the old weapon
              if (sandbox.currentWeapon) {
                weaponScene.remove(sandbox.currentWeapon);
                utils.weapons.stopAnimation("idle");
                new TWEEN.Tween(sandbox.currentWeapon.children[0].position).to({ y: -0.4 }, 100).easing(TWEEN.Easing.Quadratic.InOut).start();
              }

              // Add the new weapon
              sandbox.primaryWeapon.children[0].position.y = -0.4;
              utils.weapons.setCurrent(sandbox.primaryWeapon);
              weaponScene.add(sandbox.primaryWeapon);
              utils.weapons.playAnimation("idle");
              new TWEEN.Tween(sandbox.currentWeapon.children[0].position).to({ y: 0 }, 300).easing(TWEEN.Easing.Quadratic.InOut).start();
            } else if (set == "secondary") {
              if (!pickingUp) THREE.Sound("preloaded:weapon_switch_secondary", false);

              // Remove the old weapon
              if (sandbox.currentWeapon) {
                weaponScene.remove(sandbox.currentWeapon);
                utils.weapons.stopAnimation("idle");
                new TWEEN.Tween(sandbox.currentWeapon.children[0].position).to({ y: -0.4 }, 100).easing(TWEEN.Easing.Quadratic.InOut).start();
              }

              // Add the new weapon
              sandbox.secondaryWeapon.children[0].position.y = -0.4;
              utils.weapons.setCurrent(sandbox.secondaryWeapon);
              weaponScene.add(sandbox.secondaryWeapon);
              utils.weapons.playAnimation("idle");
              new TWEEN.Tween(sandbox.currentWeapon.children[0].position).to({ y: 0 }, 300).easing(TWEEN.Easing.Quadratic.InOut).start();
            }
            utils.weapons.update(!pickingUp);
            if (!initial) gametime.run("weaponSwitch", [gametime.player.uuid, sandbox.currentWeapon.alias.name]);
          },
          getCurrent: function(opposite = false) {
            let current;
            if (opposite) {
              current = sandbox.currentWeapon == sandbox.primaryWeapon ? "secondary" : "primary";
            } else {
              current = sandbox.currentWeapon == sandbox.primaryWeapon ? "primary" : "secondary";
            }
            return current;
          },
          melee: async function() {
            if (utils.options.get("Zoomed")) return utils.weapons.zoom(true);
            if (utils.options.get("Running")) utils.weapons.cancelRun(true);
            if (utils.options.get("Shooting")) return;
            if (utils.options.get("Reloading")) return;
            if (utils.options.get("Melee")) return;
            if (utils.strength.getCurrent() < 20) return;
            utils.options.set("Melee", true);

            THREE.Sound("preloaded:weapon_melee", false);
            new TWEEN.Tween(sandbox.currentWeapon.children[0].position).to({ z: 0.1 }, 200).easing(TWEEN.Easing.Quadratic.Out).start();
            await plugins.realDelay(150);

            utils.camera.stopShake();
            utils.camera.shake(0.8, 150);

            utils.strength.decrement(20);

            new TWEEN.Tween(sandbox.currentWeapon.children[0].position).to({ z: 0 }, 500).easing(TWEEN.Easing.Quadratic.Out).start();

            let closestPlayerObject = null;
            for (let i = 0; i < opposingPlayerObjects.length; i++) {
              if (i == 0) closestPlayerObject = opposingPlayerObjects[i];
              if (camera.position.distanceTo(opposingPlayerObjects[i].model.position) <= camera.position.distanceTo(closestPlayerObject.model.position)) closestPlayerObject = opposingPlayerObjects[i];
            }
            if (closestPlayerObject) {
              let fakePlayerObject = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1));
              fakePlayerObject.position.copy(closestPlayerObject.model.position);
              fakePlayerObject.position.y += 0.5;

              if (utils.camera.objectInView(fakePlayerObject) && camera.position.distanceTo(closestPlayerObject.model.position) < 2) {
                let playerCenter = closestPlayerObject.model.position.clone();
                playerCenter.y += 1;

                let distanceToPlayer = camera.position.distanceTo(playerCenter);
                let lungeDistance = Math.max(distanceToPlayer - 0.5, 0);
                let initialPosition = camera.position.clone();

                camera.lookAt(playerCenter);
                function animatePlayerVelocity() {
                  playerVelocity.add(getForwardVector().multiplyScalar(10));
                  const currentDistance = camera.position.distanceTo(initialPosition);
                  if (currentDistance >= lungeDistance - 0.2) {
                    playerVelocity.set(0, 0, 0);
                    utils.player.meleeHit(closestPlayerObject.uuid, gametime.player.uuid, 60);
                    return;
                  }
                  requestAnimationFrame(animatePlayerVelocity);
                }
                animatePlayerVelocity();
              } else if (camera.position.distanceTo(closestPlayerObject.model.position) < 1.2) {
                utils.player.meleeHit(closestPlayerObject.uuid, gametime.player.uuid, 60);
              }
            }

            await plugins.realDelay(500);

            if (utils.options.get("Walking")) {
              if (utils.options.get("Running")) {
                if (!utils.options.get("Zoomed")) utils.camera.shake(0.2, 100, true);
              } else {
                if (!utils.options.get("Zoomed")) utils.camera.shake(0.2, 200, true);
              }
            }

            utils.options.set("Melee", false);
          },
          effects: {
            bulletHole: function(randomSpread) {
              let ammoType = sandbox.currentWeapon.alias.ammoType;
              let bulletHoleTexture = utils.cache.read("bulletHole", ammoType);
              let raycaster = new THREE.Raycaster();
              let weapon = sandbox.currentWeapon.alias;

              const randomX = randomSpread.x;
              const randomY = randomSpread.y;

              raycaster.setFromCamera({ x: randomX, y: randomY }, camera);
              raycaster.layers.disable(1);
              raycaster.layers.disable(2);
              raycaster.layers.disable(3);
              const intersects = raycaster.intersectObjects(scene.children);

              if (intersects.length > 0) {
                const intersect = intersects[0];
                let fakeIntersection = {
                  faceNormal: intersect.face.normal.clone(),
                  objectName: intersect.object.name,
                  point: intersect.point.clone()
                };
                gametime.run("weaponEffectBulletHole", [gametime.player.uuid, fakeIntersection, ammoType]);

                let speed;
                if (ammoType === "rocket") {
                  speed = 10;
                } else {
                  speed = 250;
                }

                // The bullet travels at 250 m/s, so we'll detect a collision when the bullet hits, instead of instantly
                let distanceToCollision = intersect.distance;
                let timeUntilCollision = Math.round((distanceToCollision / speed) * 1000);
                setTimeout(() => {
                  if (intersect.object.userData.ignoreBulletEffects) return;
                  if (intersect.object.name == "BodyFollower") {
                    utils.player.bulletHit(intersect.object.userData.playerUUID, gametime.player.uuid, weapon, false);
                  } else if (intersect.object.name == "HeadFollower") {
                    utils.player.bulletHit(intersect.object.userData.playerUUID, gametime.player.uuid, weapon, true);
                  }

                  if (!utils.options.get("AimingAtPlayer")) {
                    const scale = ammoType === "rocket" ? 5 : 0.05;
                    const size = new THREE.Vector3(scale, scale, scale);
                    const normal = intersect.face.normal.clone();
                    normal.transformDirection(intersect.object.matrixWorld);
                    const rotation = new THREE.Euler().setFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), normal));

                    const decalMaterial = new THREE.MeshPhongMaterial({
                      map: bulletHoleTexture,
                      transparent: true,
                      depthTest: true,
                      depthWrite: false,
                      polygonOffset: true,
                      polygonOffsetFactor: -4,
                      side: THREE.DoubleSide
                    });
                    const decalGeometry = new THREE.DecalGeometry(intersect.object, intersect.point, rotation, size);

                    const decalMesh = new THREE.Mesh(decalGeometry, decalMaterial);
                    decalMesh.layers.set(3);
                    scene.add(decalMesh);

                    if (ammoType === "rocket") {
                      let impactPoint = new THREE.Mesh();
                      impactPoint.position.set(intersect.point.x, intersect.point.y, intersect.point.z);
                      utils.weapons.grenades.explosionEffect(impactPoint);
                    }

                    async function dispose() {
                      let fadeTime = 2000;
                      new TWEEN.Tween(decalMaterial).to({ opacity: 0 }, fadeTime).easing(TWEEN.Easing.Quadratic.Out).start();
                      await plugins.delay(fadeTime);
                      scene.remove(decalMesh);
                      decalMaterial.map.dispose();
                      decalMaterial.dispose();
                      decalGeometry.dispose();
                      bulletHoleTexture = null;
                      raycaster = null;
                    }

                    setTimeout(dispose, 10000);
                  }
                }, timeUntilCollision);
              }
            },
            bulletSpark: function(randomSpread) {
              if (sandbox.currentWeapon.alias.ammoType === "rocket") {
                let group = new THREE.Group();
                let bullet;

                // Speed unit is m/s
                let speed = 50;
                let duration = 2000;
                let distance = speed * (duration / 1000);

                if (sandbox.currentWeapon.children[0].userData.rocketProjectile) {
                  let holder = sandbox.currentWeapon.getObjectByName(sandbox.currentWeapon.children[0].userData.rocketProjectileHolder);
                  let fakeHolder = sandbox.currentWeapon.getObjectByName(sandbox.currentWeapon.children[0].userData.rocketProjectileHolderFake);
                  holder.visible = true;
                  fakeHolder.visible = false;

                  bullet = sandbox.currentWeapon.getObjectByName(sandbox.currentWeapon.children[0].userData.rocketProjectile);
                  distance *= sandbox.currentWeapon.children[0].userData.rocketScale;
                  bullet.userData.ignoreBulletEffects = true;

                  let defaultPosition = holder.userData.defaultPosition;
                  holder.position.copy(sandbox.currentWeapon.position);
                  holder.rotation.copy(camera.rotation);
                  holder.rotation.order = "YXZ";
                  holder.rotateY(Math.PI);
                  holder.translateX(defaultPosition.x);
                  holder.translateY(defaultPosition.y);
                  holder.translateZ(defaultPosition.z);

                  scene.add(holder);
                } else {
                  bullet = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 7, 20), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
                  bullet.userData.ignoreBulletEffects = true;

                  group.position.copy(camera.position);
            
                  let direction = new THREE.Vector3(0, 0, -1);
                  direction.unproject(camera);
                  direction.sub(camera.position).normalize();
                
                  group.lookAt(group.position.clone().add(direction));
                
                  bullet.rotateX(Math.PI / 2);
                  bullet.scale.set(0.01, 0.01, 0.01);
                  bullet.position.z = -5;

                  group.add(bullet);
                  scene.add(group);
                }

                new TWEEN.Tween(bullet.position).to({ z: distance }, duration).easing(TWEEN.Easing.Quadratic.In).start();
              } else {
                let group = new THREE.Group();
                let bullet = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2, 16), new THREE.MeshBasicMaterial());
                bullet.userData.ignoreBulletEffects = true;

                group.position.copy(camera.position);

                let direction = new THREE.Vector3(randomSpread.x, randomSpread.y, -1);
                direction.unproject(camera);
                direction.sub(camera.position).normalize();

                group.lookAt(group.position.clone().add(direction));

                bullet.rotateX(Math.PI / 2);
                bullet.scale.set(0.01, 0.01, 0.01);
                bullet.position.z = -1;

                // Speed unit is m/s
                let speed = 250;
                let duration = 2000;
                let distance = speed * (duration / 1000);

                group.add(bullet);
                scene.add(group);

                new TWEEN.Tween(bullet.position).to({ z: distance }, duration).easing(TWEEN.Easing.Quadratic.InOut).start();

                async function dispose() {
                  scene.remove(group);
                  group.remove(bullet);
                  bullet.material.dispose();
                  bullet.geometry.dispose();
                }

                setTimeout(dispose, 2000);
              }
            },
          },
          grenades: {
            throw: async function(animation = true, reduceGrenades = true) {
              if (utils.options.get("Running")) return utils.weapons.cancelRun();

              // Make sure the player isn't already throwing a grenade
              if (utils.options.get("ThrowingGrenade") || (reduceGrenades ? sandbox.grenades.current <= 0 : false)) return;
              utils.options.set("ThrowingGrenade", true);

              // Decrement the grenade count
              if (reduceGrenades) sandbox.grenades.current--;

              // If the gun is zoomed in, automatically zoom out
              if (utils.options.get("Zoomed")) await plugins.delay(utils.weapons.zoom(true));

              let grenadeUUID = gametime.uuidv4();
              if (animation) {
                gametime.run("weaponEffectGrenadeToss", [gametime.player.uuid, grenadeUUID, (playerCollider.end.x + "," + playerCollider.end.y + "," + playerCollider.end.z + "," + playerDirection.x + "," + playerDirection.y + "," + playerDirection.z + "," + camera.rotation.x + "," + camera.rotation.y + "," + camera.position.z + "," + playerVelocity.x + "," + playerVelocity.y + "," + playerVelocity.z)]);
                THREE.Sound(`preloaded:grenadetoss`, false);
                (async () => {
                  new TWEEN.Tween(sandbox.currentWeapon.children[0].position).to({ y: -0.4 }, 100).easing(TWEEN.Easing.Quadratic.InOut).start();
                  new TWEEN.Tween(sandbox.currentWeapon.children[0].rotation).to({ x: 0.3 }, 400).easing(TWEEN.Easing.Quadratic.InOut).start();
                  await plugins.delay(500);
                  new TWEEN.Tween(sandbox.currentWeapon.children[0].position).to({ y: 0 }, 300).easing(TWEEN.Easing.Quadratic.InOut).start();
                  new TWEEN.Tween(sandbox.currentWeapon.children[0].rotation).to({ x: 0 }, 300).easing(TWEEN.Easing.Quadratic.InOut).start();
                  utils.options.set("ThrowingGrenade", false);
                })();
                await plugins.delay(400);
              }

              const grenadeId = utils.weapons.grenades.getAvailable();
              const grenade = grenades[grenadeId];
              grenade.available = false;
              grenade.uuid = grenadeUUID;
              camera.getWorldDirection(playerDirection);
              grenade.collider.center.copy(playerCollider.end).addScaledVector(playerDirection, playerCollider.radius * 1.5);
              const impulse = 40;
              grenade.velocity.copy(playerDirection).multiplyScalar(impulse);
              grenade.angularVelocity.set(0, 0, 0);
              grenade.velocity.addScaledVector(playerVelocity, 2);
              scene.add(grenade.mesh);

              // Just in case the grenade never explodes, we'll reset it after a certain time
              let resetId = grenade.resetId.toString();
              setTimeout(() => {
                if (grenades[grenade.id].resetId === resetId) utils.weapons.grenades.reset(grenade.id);
              }, 10000);

              if (!animation) utils.options.set("ThrowingGrenade", false);
            },
            reset: function(grenadeId) {
              grenades[grenadeId] = {
                mesh: grenades[grenadeId].mesh,
                collider: new THREE.Sphere(new THREE.Vector3(0, -100, 0), 0.1),
                velocity: new THREE.Vector3(),
                angularVelocity: new THREE.Vector3(),
                available: true,
                hits: 0,
                explode: true,
                uuid: null,
                id: grenadeId,
                resetId: gametime.uuidv4()
              };
              grenades[grenadeId].collider.center.y = -100;
            },
            explosion: async function(grenade, grenadeId, delay = 2000, firstPerson = true, grenadeUUID) {
              await plugins.realDelay(delay);
              if (firstPerson) gametime.run("weaponEffectGrenadeExplode", [gametime.player.uuid, grenadeUUID, (grenade.position.x + "," + grenade.position.y + "," + grenade.position.z)]);
              utils.weapons.grenades.reset(grenadeId);
              scene.remove(grenade);

              utils.weapons.grenades.explosionEffect(grenade, grenadeId, delay, firstPerson, grenadeUUID);
            },
            explosionEffect: async function(grenade, grenadeId, delay = 2000, firstPerson = true, grenadeUUID) {
              let index = 0;
              let explosion = sandbox.models["explosion"].model;
              explosion.traverse(async object => {
              if (!object.name.startsWith("Object")) return;
                index++;
                object.scale.set(.05, .05, .05);
                object.material.transparent = true;
                object.material.opacity = 1;
                let timing = 50 * (10 - index);
                new TWEEN.Tween(object.scale).to({ x: 1, y: 1, z: 1 }, timing).easing(TWEEN.Easing.Quadratic.InOut).start();
                await plugins.delay(100);
                let originalIndex = index - 0;
                new TWEEN.Tween(object.material).to({ opacity: 0 }, 500).easing(TWEEN.Easing.Quadratic.InOut).start().onUpdate(function() {
                  if (originalIndex == 0 && object.material.opacity <= 0) {
                    scene.remove(explosion);
                    explosion.position.y = -1000;
                  }
                });
              });
              explosion.position.copy(grenade.position);
              scene.add(explosion);
              
              const explosionLight = utils.cache.read("explosionLight", "main");
              const explosionLightClone = utils.cache.read("explosionLight", "clone");
              
              explosionLight.position.copy(grenade.position);
              explosionLightClone.position.copy(explosionLight.position);
              scene.add(explosionLight);
              weaponScene.add(explosionLightClone);
              
              function animateExplosionLight() {
                const duration = 500;
                const startTime = Date.now();
              
                function update() {
                  const elapsedTime = Date.now() - startTime;
                  const progress = Math.min(elapsedTime / duration, 1);
              
                  explosionLight.intensity = 10 * (1 - progress);
                  explosionLightClone.intensity = 10 * (1 - progress);
              
                  if (progress < 1) {
                    requestAnimationFrame(update);
                  } else {
                    scene.remove(explosionLight);
                    weaponScene.remove(explosionLightClone);
                  }
                }
              
                update();
              }
              animateExplosionLight();

              THREE.Sound(`preloaded:grenadeexplosion_Frag`, true, explosion, () => {}, 20, 0.5);

              // If the player is within the explosion radius of 4.5 meters, they will take damage
              for (let i = 0; i < opposingPlayerObjects.length; i++) {
                let position = opposingPlayerObjects[i].model.position.clone();
                position.y += 1;
                if (position.distanceTo(explosion.position) <= 4.5) {
                  let distance = opposingPlayerObjects[i].model.position.distanceTo(explosion.position);
                  let damage = Math.round((4.5 - distance) * 20);
                  utils.player.grenadeHit(opposingPlayerObjects[i].uuid, gametime.player.uuid, damage);
                }
              }
            },
            ricochet: async function(grenade) {
              if (utils.options.get("DoingRicochet")) return;
              utils.options.set("DoingRicochet", true);

              if (grenade.available) return;
              let sparkTexture = utils.cache.read("bulletHole", "spark");
              let spark = new THREE.Mesh(new THREE.CircleGeometry(.3, 20), new THREE.MeshBasicMaterial({ map: sparkTexture, transparent: true }));
              spark.position.copy(grenade.mesh.position);
              spark.lookAt(camera.position);
              scene.add(spark);
              let ricochet = Math.floor(Math.random() * 4) + 1;
              THREE.Sound(`preloaded:grenadericochet${ricochet}`, true, spark, () => {}, 6, 0.2);

              await plugins.delay(50);
              scene.remove(spark);
              spark.geometry.dispose();
              spark.material.dispose();
              spark = null;
              sparkTexture = null;
              utils.options.set("DoingRicochet", false);
            },
            getAvailable: function() {
              let results = [];
              for (let i = 0; i < grenades.length; i++) {
                if (grenades[i].available) results.push(i);
              }
              return results[0];
            }
          },
          setPrimary: function(model) {
            sandbox.primaryWeapon = model;
            sandbox.primaryWeapon.alias = sandbox.weapons[model.children[0].userData.name.split(".glb")[0]];
          },
          setSecondary: function(model) {
            sandbox.secondaryWeapon = model;
            sandbox.secondaryWeapon.alias = sandbox.weapons[model.children[0].userData.name.split(".glb")[0]];
          },
          setCurrent: function(model) {
            sandbox.currentWeapon = model;
            sandbox.currentWeapon.alias = sandbox.weapons[model.children[0].userData.name.split(".glb")[0]];
          },
          pickUp: function(weapon, options = {}) {
            if (sandbox.loadout.includes(weapon)) {
              THREE.Sound("preloaded:weapon_magazine_pickup", false);

              sandbox.weapons[weapon].magazineCurrent += sandbox.weapons[weapon].magazineCapacity;
              utils.weapons.update();
              return;
            }

            THREE.Sound("preloaded:weapon_drop", false);

            let currentWeapon = utils.weapons.getCurrent();
            let oppositeWeapon = utils.weapons.getCurrent();
            utils.weapons.switch(oppositeWeapon, false, true);
            utils.options.set("Reloading", false);

            if (currentWeapon === "primary") {
              sandbox.loadout[0] = weapon;
              utils.weapons.setPrimary(sandbox.models[`weapon_${weapon}`].model);
            } else if (currentWeapon === "secondary") {
              sandbox.loadout[1] = weapon;
              utils.weapons.setSecondary(sandbox.models[`weapon_${weapon}`].model);
            }

            utils.weapons.switch(currentWeapon, false, true);

            sandbox.currentWeapon.alias.magazineCurrent = sandbox.currentWeapon.alias.magazineCapacity;
            sandbox.currentWeapon.alias.ammoCurrent = sandbox.currentWeapon.alias.ammoCapacity;

            if (typeof options.ammo !== "undefined") sandbox.currentWeapon.alias.ammoCurrent = options.ammo;
            if (typeof options.magazines !== "undefined") sandbox.currentWeapon.alias.magazineCurrent = options.magazines;

            utils.weapons.update(true);
          },
          spawn: function(weapon, position, rotation, inCrate = true, wasDropped = false, options = {}) {
            let crateIndex = Object.keys(deployedCrates).length + 1;
            if (inCrate) {
              let crateId = gametime.uuidv4() + ":" + crateIndex;
              let weaponCrate = sandbox.models["crate"].model.clone();
              weaponCrate.position.set(position.x, position.y + 0.03, position.z);
              weaponCrate.rotation.set(rotation.x, rotation.y, rotation.z);
              weaponCrate.userData.messageShown = false;
              weaponCrate.userData.weaponName = weapon;
              weaponCrate.userData.crateIndex = crateIndex;
              scene.add(weaponCrate);
              deployedCrates[crateId] = weaponCrate;
              utils.effects.outline.add(weaponCrate);

              let pointer = THREE.Text.createPointerText(weapon, 16, "Arame");
              pointer.position.copy(weaponCrate.position);
              weaponCrate.userData.pointerUUID = pointer.userData.pointerUUID;
              scene.add(pointer);
            } else {
              let crateId = gametime.uuidv4() + ":" + crateIndex;
              let propWeapon = sandbox.models[`propweapon_${weapon}`].model.clone();
              propWeapon.position.set(position.x, position.y, position.z);
              propWeapon.rotation.set(rotation.x, rotation.y, rotation.z + (Math.PI / 2));
              propWeapon.rotation.order = "YXZ";
              propWeapon.scale.set(0.07, 0.07, 0.07);
              propWeapon.userData.messageShown = false;
              propWeapon.userData.weaponName = weapon;
              propWeapon.userData.crateIndex = crateIndex;
              scene.add(propWeapon);
              deployedCrates[crateId] = propWeapon;
              utils.effects.outline.add(propWeapon);

              if (wasDropped) {
                if (typeof options.ammo !== "undefined" && typeof options.magazines !== "undefined") {
                  propWeapon.userData.ammo = options.ammo;
                  propWeapon.userData.magazines = options.magazines;
                }
                function dispose() {
                  if (deployedCrates[crateId]) {
                    utils.weapons.despawn(crateId, false);
                  }
                }
                
                setTimeout(dispose, 30000);
              }
            }
          },
          despawn: function(crateId, dropWeapon = true) {
            let weaponData = utils.weapons.getMetadata(sandbox.currentWeapon.alias.name);

            let crate = deployedCrates[crateId];
            let index = crateId.split(":")[1];
            utils.effects.hideMessage(index);
            utils.effects.outline.remove(crate);
            if (crate.userData.pointerUUID) THREE.Text.removePointerText(crate.userData.pointerUUID);
            deployedCrates[crateId] = null;

            crate.traverse(object => {
              if (object.geometry) object.geometry.dispose();
              if (object.material) object.material.dispose();
              if (object.dispose) object.dispose();
            });
            scene.remove(crate);

            crate = null;

            let currentWeapon = sandbox.currentWeapon.alias.name;
            let currentPosition = new THREE.Vector3(camera.position.x, camera.position.y - 0.97, camera.position.z);
            let currentRotation = new THREE.Vector3(0, camera.rotation.y, 0);
            
            if (dropWeapon) utils.weapons.spawn(currentWeapon, currentPosition, currentRotation, false, true, weaponData);

            gametime.run("weaponDespawn", [gametime.player.uuid, crateId.split(":")[1], dropWeapon]);
          },
          update: async function(switchingWeapons = false) {
            document.querySelector(".weapon-ammo-number").textContent = Math.max(sandbox.currentWeapon.alias.ammoCurrent, 0);
            document.querySelector(".weapon-magazine-number").textContent = Math.max(sandbox.currentWeapon.alias.magazineCurrent, 0);

            let weaponImageSrc = `/images/other/weapons/${sandbox.currentWeapon.alias.name}.png`;
            if (document.querySelector(".weapon-icon img").src !== weaponImageSrc) document.querySelector(".weapon-icon img").src = weaponImageSrc;

            if (sandbox.currentWeapon.alias.ammoCurrent <= 0 && switchingWeapons) {
              utils.options.set("Reloading", true);
              let currentWeapon = utils.weapons.getCurrent();
              await plugins.delay(500);
              let newWeapon = utils.weapons.getCurrent();
              if (newWeapon == currentWeapon) {
                utils.options.set("CancelReload", false);
                utils.options.set("Reloading", false);
                utils.weapons.reload(true);
              }
            }
          }
        },
        camera: {
          updatePosition: function() {
            weaponCamera.position.copy(camera.position);
            weaponCamera.rotation.copy(camera.rotation);
          },
          updateVision: function() {
            if (utils.options.get("Shooting") || !sandbox.models["character"].loaded) return;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            raycaster.layers.disable(1);
            raycaster.layers.enable(2);

            const aimingObjects = utils.cache.read("raycaster", "aimingObjects");
            const intersects = raycaster.intersectObjects(aimingObjects);
        
            if (intersects.length === 0) {
              utils.options.set("AutoLock", false);
              utils.options.set("AutoLockPosition", null);
              utils.options.set("AimingAtPlayer", false);
              return;
            }

            const hitObject = intersects[0].object;
            utils.options.set("AutoLock", true);
            if (utils.options.get("CameraTurning")) {
              utils.options.set("AutoLockPosition", intersects[0].point);
            }

            if (hitObject.name !== "AimFollower") {
              utils.options.set("AimingAtPlayer", true);
              return;
            }

            const isAimingAtPlayer = intersects.slice(1, 3).some(intersection => /HeadFollower|BodyFollower/g.test(intersection.object.name));
            utils.options.set("AimingAtPlayer", isAimingAtPlayer);
          },
          hideUI: function(ignoreDeathCam = false, ignoreCountdown = false) {
            document.querySelectorAll(".ui *").forEach(element => {
              if (element.classList.contains("ignore")) return;
              if ((element.classList.contains("death-cam") && ignoreDeathCam) || (element.classList.contains("clock") && ignoreCountdown)) {
                element.style.visibility = "visible";
              } else {
                element.style.visibility = "hidden";
              }
            });
          },
          showUI: function() {
            document.querySelectorAll(".ui *").forEach(element => {
              if (element.classList.contains("ignore")) return;
              element.style.visibility = "";
            });
          },
          objectInView: function(object) {
            scene.updateMatrixWorld(true);
            camera.updateMatrixWorld(true);
            object.updateMatrixWorld(true);
            camera.getWorldQuaternion(new THREE.Quaternion());

            const directionVector = new THREE.Vector3();
            directionVector.subVectors(object.position, camera.position);
            const cameraDirection = new THREE.Vector3(0, 0, -1);
            cameraDirection.applyQuaternion(camera.quaternion);
            const angle = cameraDirection.angleTo(directionVector);
            const verticalFOVRadians = THREE.MathUtils.degToRad(camera.fov);
            const aspect = camera.aspect;
            const horizontalFOVRadians = 2 * Math.atan(Math.tan(verticalFOVRadians / 2) * aspect);
            const maxFOVRadians = Math.max(verticalFOVRadians, horizontalFOVRadians);

            let isInView = angle <= maxFOVRadians / 2;
            return isInView;
          },
          shake: async function(intensity = 1, duration = 50, repeat = false, defaultFov = 60) {
            const MAX_ROTATION_X = Math.PI / 2;
          
            async function next(repeat = false) {
              if (utils.options.get("CancelCameraShake")) return utils.options.set("CancelCameraShake", false);
              if (utils.options.get("CameraShaking")) return;
              utils.options.set("CameraShaking", true);
          
              let outFov = defaultFov + intensity;
              let inFov = defaultFov;
              let rotationX = 0.01 * intensity;
              let rotationY = 0.005 * intensity;
          
              new TWEEN.Tween(camera).to({ fov: outFov }, duration).easing(TWEEN.Easing.Quadratic.InOut).start().onUpdate(function() {
                // Store the current z-rotation
                const currentZRotation = camera.rotation.z;
          
                // Create quaternions for x and y rotations
                const qx = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), rotationX);
                const qy = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationY);
          
                // Combine rotations
                const combinedRotation = qx.multiply(qy);
          
                // Apply the combined rotation to the camera's quaternion
                camera.quaternion.premultiply(combinedRotation);
          
                // Clamp the x-rotation
                const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                euler.x = Math.max(-MAX_ROTATION_X, Math.min(MAX_ROTATION_X, euler.x));
          
                // Set the camera's quaternion from the clamped euler angles, preserving z-rotation
                camera.quaternion.setFromEuler(euler);
                camera.rotation.z = currentZRotation;
          
                camera.updateProjectionMatrix();
              });
          
              await plugins.delay(duration);
          
              new TWEEN.Tween(camera).to({ fov: inFov }, duration).easing(TWEEN.Easing.Quadratic.InOut).start().onUpdate(function() {
                // Repeat the process for the reverse motion
                const currentZRotation = camera.rotation.z;
                const qx = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -rotationX);
                const qy = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), -rotationY);
                const combinedRotation = qx.multiply(qy);
                camera.quaternion.premultiply(combinedRotation);
          
                const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                euler.x = Math.max(-MAX_ROTATION_X, Math.min(MAX_ROTATION_X, euler.x));
          
                camera.quaternion.setFromEuler(euler);
                camera.rotation.z = currentZRotation;
          
                camera.updateProjectionMatrix();
              });
          
              await plugins.delay(duration);
          
              utils.options.set("CameraShaking", false);
          
              if (repeat) next(true);
            }
          
            if (repeat) {
              next(true);
            } else {
              next();
            }
          },
          stopShake: function() {
            if (!utils.options.get("CameraShaking")) return;
            utils.options.set("CancelCameraShake", true);
          }
        },
        effects: {
          playerHit: async function(impact) {
            THREE.Sound.stop("preloaded:playerhit");
            THREE.Sound("preloaded:playerhit", false);

            let styling = {
              rotate: 0
            };
            let multiplier = Math.floor(Math.random() * 2) === 0 ? -1 : 1;
            multiplier += Math.random() / 10;
            let impactScale = 1.3 * (impact / 100) * multiplier;
            let impactRotate = -10 * (impact / 100) * multiplier;
            document.querySelector(".hit-marker").style.visibility = "visible";
            document.querySelector(".hit-marker").style.scale = 0.6;
            document.querySelector(".hit-marker").style.rotate = "0deg";
            new TWEEN.Tween(document.querySelector(".hit-marker").style).to({ scale: impactScale }, 100).easing(TWEEN.Easing.Quadratic.In).start();
            new TWEEN.Tween(styling).to({ rotate: impactRotate }, 100).easing(TWEEN.Easing.Quadratic.In).start().onUpdate(function() { document.querySelector(".hit-marker").style.rotate = `${styling.rotate}deg` });
            await plugins.delay(100);
            new TWEEN.Tween(document.querySelector(".hit-marker").style).to({ scale: 0.6 }, 50).easing(TWEEN.Easing.Quadratic.In).start();
            new TWEEN.Tween(styling).to({ rotate: 0 }, 50).easing(TWEEN.Easing.Quadratic.In).start().onUpdate(function() { document.querySelector(".hit-marker").style.rotate = `${styling.rotate}deg` });
            await plugins.delay(50);
            document.querySelector(".hit-marker").style.visibility = "hidden";
          },
          outline: {
            add: function(object) {
              let outlineShader = {
                uniforms: {
                  tDiffuse: { value: null },
                  resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                  outlineStrength: { value: 1 }
                },
                vertexShader: `
                uniform float outlineThickness;

                void main() {
                  vec4 pos = modelViewMatrix * vec4(position, 1.0);
                  vec3 normal = normalize(normalMatrix * normal);
                  pos.xyz += normal * outlineThickness;
                  gl_Position = projectionMatrix * pos;
                }
                `,
                fragmentShader: `
                uniform vec3 outlineColor;

                void main() {
                  gl_FragColor = vec4(outlineColor, 1.0);
                }
                `
              };

              let outlineMaterial = new THREE.ShaderMaterial({
                uniforms: {
                  outlineThickness: { value: 0.01 },
                  outlineColor: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: outlineShader.vertexShader,
                fragmentShader: outlineShader.fragmentShader,
                side: THREE.BackSide
              });
              
              let outlineMesh = object.clone();
              outlineMesh.traverse(x => {
                if (x.material) x.material = outlineMaterial;
              });

              scene.add(outlineMesh);

              let outlineId = gametime.uuidv4();
              object.userData.outlineUUID = outlineId;
              let outlines = utils.cache.read("outlines", "saved");
              outlines[outlineId] = outlineMesh;
              utils.cache.write("outlines", "saved", outlines);

              outlineShader = null;
              outlineMaterial = null;
              outlineMesh = null;
              outlineId = null;
              outlines = null;
            },
            remove: function(object) {
              let outlineId = null;
              object.traverse(x => {
                if (x.userData && x.userData.outlineUUID) outlineId = x.userData.outlineUUID;
              });

              let outlines = utils.cache.read("outlines", "saved");

              outlines[outlineId].traverse(x => {
                if (x.geometry) x.geometry.dispose();
                if (x.material) x.material.dispose();
                if (x.dipose) x.dispose();
              });

              scene.remove(outlines[outlineId]);
              delete outlines[outlineId];

              utils.cache.write("outlines", "saved", outlines);

              outlineId = null;
              outlines = null;
            }
          },
          showMessage: function(text, id) {
            document.querySelector(".ui .message-wrapper .message").textContent = text;
            document.querySelector(".ui .message-wrapper .message").dataset.messageId = id;
            document.querySelector(".ui .message-wrapper").style.opacity = 1;
          },
          hideMessage: function(id) {
            if (document.querySelector(".ui .message-wrapper .message").dataset.messageId == id) {
              document.querySelector(".ui .message-wrapper .message").dataset.messageId = -1;
              document.querySelector(".ui .message-wrapper").style.opacity = 0;
            }
          }
        },
        player: {
          getObject: function(uuid) {
            return opposingPlayerObjects.filter(x => x.uuid === uuid).slice(-1)[0];
          },
          bulletHit: function(player, opposingPlayer, weapon, headshot) {
            let distanceDecay = camera.position.distanceTo(utils.player.getObject(player).model.position) / 5;
            let damage = headshot ? weapon.headshotDamage : Math.max(weapon.damage - distanceDecay, 0);
            gametime.run("playerHit", [player, opposingPlayer, damage, headshot]);
            utils.effects.playerHit(damage);
          },
          grenadeHit: function(player, opposingPlayer, damage, grenadeType) {
            gametime.run("playerHit", [player, opposingPlayer, damage, false, grenadeType]);
            utils.effects.playerHit(damage);
          },
          meleeHit: function(player, opposingPlayer, damage) {
            gametime.run("playerHit", [player, opposingPlayer, damage, false]);
            utils.effects.playerHit(damage);
          },
          playerCache: {
            create: function(uuid) {
              utils.player.playerCache[uuid] = {};
            },
            get: function(uuid, key) {
              let value = utils.player.playerCache[uuid][key];
              if (typeof value === "undefined") value = null;
              return value;
            },
            set: function(uuid, key, value) {
              utils.player.playerCache[uuid][key] = value;
            }
          },
          health: {
            increase: function(uuid, increment) {
              let newHealth = utils.player.playerCache.get(uuid, "health") + increment;
              if (newHealth > 100) newHealth = 100;

              utils.player.playerCache.set(uuid, "health", newHealth);
            },
            decrease: function(uuid, opposingUUID, decrement, headshot = false) {
              let newHealth = utils.player.playerCache.get(uuid, "health") - decrement;
              plugins.clearRealTimeout(utils.player.playerCache.get(uuid, "healthIncrementTimeout"));
              plugins.clearRealInterval(utils.player.playerCache.get(uuid, "healthIncrementInterval"));
              if (newHealth <= 0) {
                newHealth = 0;
                utils.player.playerCache.set(uuid, "health", newHealth);
                utils.player.health.die(uuid, opposingUUID, headshot);
                return;
              }

              let incrementTimeout = plugins.realTimeout(() => {
                let incrementInterval = plugins.realInterval(() => {
                  if (newHealth >= 100) return newHealth = 100, plugins.clearRealInterval(incrementInterval);
                  newHealth++;
                  utils.player.health.increase(uuid, 1);
                }, 50);
                utils.player.playerCache.set(uuid, "healthIncrementInterval", incrementInterval);
              }, 6000);
              utils.player.playerCache.set(uuid, "healthIncrementTimeout", incrementTimeout);

              utils.player.playerCache.set(uuid, "health", newHealth);
            },
            set: function(uuid, opposingUUID, health) {
              if (health <= 0) {
                return utils.player.health.decrease(uuid, opposingUUID, 100);
              }
              utils.player.playerCache.set(uuid, "health", health);
            },
            die: function(uuid, opposingUUID, headshot = false) {
              if (utils.player.playerCache.get(uuid, "dying")) return;
              utils.player.playerCache.set(uuid, "dying", true);

              let playerObject = utils.player.getObject(uuid);
              utils.player.animations.play(playerObject, "dying", () => {
                utils.player.addDeathPose(playerObject.model.position, playerObject.model.rotation, playerObject.model.scale);
                scene.remove(playerObject.model);
              });

              utils.scoreboard.add(utils.player.getObject(opposingUUID).username, sandbox.presets.killPoints);

              if (opposingUUID === gametime.player.uuid) {
                utils.medals.display(headshot);
              }
            }
          },
          respawn: function(uuid, spawnPoint) {
            let playerObject = utils.player.getObject(uuid);
            utils.player.animations.play(playerObject, "idle");
            utils.player.health.increase(uuid, 100);

            // Reset player position
            playerObject.model.position.set(spawnPoint[0], spawnPoint[1], spawnPoint[2]);
            playerObject.model.rotation.set(spawnPoint[3], spawnPoint[4], spawnPoint[5]);

            scene.add(playerObject.model);
            utils.player.playerCache.set(uuid, "dying", false);
          },
          addDeathPose: function(position, rotation, scale) {
            let deathPose = THREE.SkeletonUtils.clone(utils.cache.read("deathPose", "SWAT"));
            deathPose.traverse(object => {
              object.frustumCulled = false;
              object.layers.set(1);
            });
            deathPose.position.copy(position);
            deathPose.rotation.order = "YXZ";
            deathPose.rotation.set(rotation.x, rotation.y, rotation.z);
            deathPose.scale.copy(scale);
            scene.add(deathPose);

            function dispose() {
              scene.remove(deathPose);
              deathPose.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) object.material.dispose();
              });
              deathPose = null;
            }
            
            setTimeout(dispose, 60000);
          },
          animations: {
            play: function(playerObject, animation, callback = () => {}) {
              let animationType = utils.player.playerCache.get(playerObject.uuid, "armAnimationType");
              if (animation === "idle") {
                animation = animationType === "handheld" ? "pistol_idle" : "rifle_idle";
              } else if (animation === "walking") {
                animation = animationType === "handheld" ? "pistol_walking" : "rifle_walking";
              } else if (animation === "jumping") {
                animation = animationType === "handheld" ? "pistol_jumping" : "rifle_jumping";
              }

              let animationMaps = {
                "dying": { index: 0, repeat: false, clamp: true, clamp: true },
                "grenade_throw": { index: 1, repeat: false, clamp: false, speed: 3, start: 1.2 },
                "pistol_idle": { index: 2, repeat: true, clamp: false, speed: 0.5 },
                "pistol_jumping": { index: 3, repeat: false, clamp: false },
                "pistol_walking": { index: 4, repeat: true, clamp: false },
                "rifle_idle": { index: 5, repeat: true, clamp: false, speed: 0.5 },
                "rifle_jumping": { index: 6, repeat: false, clamp: false },
                "rifle_shooting": { index: 7, repeat: false, clamp: false },
                "rifle_walking": { index: 8, repeat: true, clamp: false }
              }
              let animationOptions = animationMaps[animation];
              let animationIndex = animationOptions.index;

              for (let i = 0; i < Object.keys(animationMaps).length; i++) {
                let clip = playerObject.mixer.clipAction(playerObject.animations[i]);
                clip.stop();
                clip.reset();
              }

              let clip = playerObject.mixer.clipAction(playerObject.animations[animationIndex]);
              if (animationOptions.repeat) {
                clip.loop = THREE.LoopRepeat;
              } else {
                clip.loop = THREE.LoopOnce;
              }
              if (animationOptions.clamp) {
                clip.clampWhenFinished = true;
              }

              clip.reset();
              if (animationOptions.speed) clip.timeScale = animationOptions.speed;
              if (animationOptions.start) clip.time = animationOptions.start;
              clip.play();

              let localPlayback = false;
              playerObject.mixer.addEventListener("finished", function() {
                if (!localPlayback) {
                  localPlayback = true;
                  callback();
                  clip.stop();
                  clip.reset();
                }
              });
            },
            stop: function(playerObject, animation) {
              let animationType = utils.player.playerCache.get(playerObject.uuid, "armAnimationType");
              if (animation === "idle") {
                animation = animationType === "handheld" ? "pistol_idle" : "rifle_idle";
              } else if (animation === "walking") {
                animation = animationType === "handheld" ? "pistol_walking" : "rifle_walking";
              } else if (animation === "jumping") {
                animation = animationType === "handheld" ? "pistol_jumping" : "rifle_jumping";
              }

              let animationMaps = {
                "dying": { index: 0, repeat: false },
                "grenade_throw": { index: 1, repeat: false },
                "pistol_idle": { index: 2, repeat: true },
                "pistol_jumping": { index: 3, repeat: false },
                "pistol_walking": { index: 4, repeat: true },
                "rifle_idle": { index: 5, repeat: true },
                "rifle_jumping": { index: 6, repeat: false },
                "rifle_shooting": { index: 7, repeat: false },
                "rifle_walking": { index: 8, repeat: true }
              }
              let animationOptions = animationMaps[animation];
              let animationIndex = animationOptions.index;

              let clip = playerObject.mixer.clipAction(playerObject.animations[animationIndex]);
              clip.stop();
              clip.reset();
            },
            fade: function(playerObject, previousAnimation, newAnimation, time) {
              let animationType = utils.player.playerCache.get(playerObject.uuid, "armAnimationType");
              if (previousAnimation === "idle") {
                previousAnimation = animationType === "handheld" ? "pistol_idle" : "rifle_idle";
              } else if (previousAnimation === "walking") {
                previousAnimation = animationType === "handheld" ? "pistol_walking" : "rifle_walking";
              } else if (previousAnimation === "jumping") {
                previousAnimation = animationType === "handheld" ? "pistol_jumping" : "rifle_jumping";
              }
              if (newAnimation === "idle") {
                newAnimation = animationType === "handheld" ? "pistol_idle" : "rifle_idle";
              } else if (newAnimation === "walking") {
                newAnimation = animationType === "handheld" ? "pistol_walking" : "rifle_walking";
              } else if (newAnimation === "jumping") {
                newAnimation = animationType === "handheld" ? "pistol_jumping" : "rifle_jumping";
              }

              let animationMaps = {
                "dying": { index: 0, repeat: false },
                "grenade_throw": { index: 1, repeat: false },
                "pistol_idle": { index: 2, repeat: true },
                "pistol_jumping": { index: 3, repeat: false },
                "pistol_walking": { index: 4, repeat: true },
                "rifle_idle": { index: 5, repeat: true },
                "rifle_jumping": { index: 6, repeat: false },
                "rifle_shooting": { index: 7, repeat: false },
                "rifle_walking": { index: 8, repeat: true }
              }
              let previousAnimationOptions = animationMaps[previousAnimation];
              let previousAnimationIndex = previousAnimationOptions.index;
              let newAnimationOptions = animationMaps[newAnimation];
              let newAnimationIndex = newAnimationOptions.index;

              let previousClip = playerObject.mixer.clipAction(playerObject.animations[previousAnimationIndex]);
              let newClip = playerObject.mixer.clipAction(playerObject.animations[newAnimationIndex]);
              newClip.reset();
              previousClip.crossFadeTo(newClip, time);
              newClip.play();
            }
          },
          weapon: {
            switch: function(uuid, weapon) {
              let playerObject = utils.player.getObject(uuid);
              if (!playerObject) return;
              playerObject.model.getObjectByName("mixamorigRightHand").remove(playerObject.model.getObjectByName("weapon-attachment"));
              let weaponModel = sandbox.models[`propweapon_${weapon}`];
              weaponModel.model.traverse(object => {
                object.layers.set(1);
              });
              weaponModel.model.scale.set(7, 7, 7);
              weaponModel.model.position.set(2, 20, 5);
              weaponModel.model.rotation.set(0, Math.PI / 2, 0);
              weaponModel.model.name = "weapon-attachment";
              playerObject.model.getObjectByName("mixamorigRightHand").add(weaponModel.model);
              utils.player.playerCache.set(uuid, "armAnimationType", weaponModel.armAnimationType);
              utils.player.animations.play(playerObject, "idle");
            }
          }
        },
        strength: {
          increment: function(value = 1) {
            utils.options.set("Strength", utils.options.get("Strength") + value);
            utils.strength.update();
          },
          decrement: function(value = 1) {
            let newStrength = utils.options.get("Strength") - value;
            if (newStrength <= 0) newStrength = 0;
            utils.options.set("Strength", newStrength);
            utils.strength.update();
          },
          set: function(value, update = false) {
            utils.options.set("Strength", value);
            if (update) utils.strength.update();
          },
          getCurrent: function() {
            return utils.options.get("Strength");
          },
          update: function() {
            let currentStrength = utils.options.get("Strength");
            if (currentStrength <= 0) currentStrength = 0;
            document.querySelector(".ui .charge-bar .charge-bar-active").style.width = `${currentStrength}%`;
            document.querySelector(".ui .charge-text").textContent = Math.round(currentStrength) + "%";
          }
        },
        health: {
          increase: function(increment) {
            let newHealth = utils.options.get("Health") + increment;
            if (newHealth > 100) newHealth = 100;

            utils.options.set("Health", newHealth);
            utils.health.update();
          },
          decrease: function(decrement, opposingPlayer) {
            let newHealth = utils.options.get("Health") - decrement;
            plugins.clearRealTimeout(utils.cache.read("health", "incrementTimeout"));
            plugins.clearRealInterval(utils.cache.read("health", "incrementInterval"));
            if (newHealth <= 0) {
              newHealth = 0;
              utils.options.set("Health", newHealth);
              utils.health.update();
              utils.health.die(opposingPlayer);
              return;
            }

            let incrementTimeout = plugins.realTimeout(() => {
              let incrementInterval = plugins.realInterval(() => {
                if (newHealth >= 100) return newHealth = 100, plugins.clearRealInterval(incrementInterval);
                newHealth++;
                utils.health.increase(1);
              }, 50);
              utils.cache.write("health", "incrementInterval", incrementInterval);
            }, 6000);
            utils.cache.write("health", "incrementTimeout", incrementTimeout);

            utils.options.set("Health", newHealth);
            utils.health.update();
          },
          update: function() {
            let currentHealth = utils.options.get("Health");
            document.querySelector(".ui .health-bar .health-bar-active").style.width = `${currentHealth}%`;
            document.querySelector(".ui .health-text").textContent = Math.round(currentHealth);

            let currentStrength = utils.options.get("Strength");
            document.querySelector(".ui .charge-bar .charge-bar-active").style.width = `${currentStrength}%`;
            document.querySelector(".ui .charge-text").textContent = Math.round(currentStrength) + "%";

            if (currentHealth <= 20) {
              document.querySelector(".ui .health-bar .health-bar-active").style.background = `var(--background-default-red)`;
              document.querySelector(".ui .health-bar .health-bar-active").style.boxShadow = `var(--box-shadow-default-red)`;
            } else if (currentHealth <= 50) {
              document.querySelector(".ui .health-bar .health-bar-active").style.background = `var(--background-default-yellow)`;
              document.querySelector(".ui .health-bar .health-bar-active").style.boxShadow = `var(--box-shadow-default-yellow)`;
            } else {
              document.querySelector(".ui .health-bar .health-bar-active").style.background = `var(--background-default-green)`;
              document.querySelector(".ui .health-bar .health-bar-active").style.boxShadow = `var(--box-shadow-default-green)`;
            }
          },
          die: async function(opposingPlayer) {
            if (utils.options.get("Dying")) return;
            utils.options.set("Dying", true);

            utils.scoreboard.add(opposingPlayer.userData.username, sandbox.presets.killPoints);

            PointerControls.isLocked = false;

            weaponScene.remove(sandbox.currentWeapon);
            utils.camera.hideUI(true);

            let currentPosition = new THREE.Vector3(camera.position.x - 0.5, camera.position.y - 0.97, camera.position.z - 0.5);
            let currentPosition1 = new THREE.Vector3(camera.position.x + 0.5, camera.position.y - 0.97, camera.position.z + 0.5);
            let currentRotation = new THREE.Vector3(0, camera.rotation.y, 0);
            let primaryWeaponOptions = utils.weapons.getMetadata(sandbox.primaryWeapon.alias.name);
            let secondaryWeaponOptions = utils.weapons.getMetadata(sandbox.secondaryWeapon.alias.name);
            utils.weapons.spawn(sandbox.primaryWeapon.alias.name, currentPosition, currentRotation, false, true, primaryWeaponOptions);
            utils.weapons.spawn(sandbox.secondaryWeapon.alias.name, currentPosition1, currentRotation, false, true, secondaryWeaponOptions);

            let firstWeapon = utils.weapons.getMetadata(sandbox.primaryWeapon.alias.name);
            let secondWeapon = utils.weapons.getMetadata(sandbox.secondaryWeapon.alias.name);
            firstWeapon.position = currentPosition.x + "," + currentPosition.y + "," + currentPosition.z;
            firstWeapon.rotation = currentRotation.x + "," + currentRotation.y + "," + currentRotation.z;
            secondWeapon.position = currentPosition1.x + "," + currentPosition1.y + "," + currentPosition1.z;
            secondWeapon.rotation = currentRotation.x + "," + currentRotation.y + "," + currentRotation.z;
            gametime.run("weaponDrop", [gametime.player.uuid, firstWeapon, secondWeapon]);

            let position = new THREE.Vector3(camera.position.x, camera.position.y - 1, camera.position.z);
            let rotation = new THREE.Vector3(0, camera.rotation.y, 0);
            let scale = new THREE.Vector3(0.0072, 0.0072, 0.0072);
            utils.player.addDeathPose(position, rotation, scale);
            camera.lookAt(opposingPlayer.position);
            camera.fov = 80;
            camera.updateProjectionMatrix();
            playerVelocity.add(getForwardVector().multiplyScalar(-10));

            await plugins.realDelay(5000);
            utils.health.respawn();
            utils.options.set("Dying", false);
          },
          respawn: function(initial = false) {
            if (!initial) {
              PointerControls.isLocked = true;

              let currentWeapon = utils.weapons.getCurrent();
              if (currentWeapon === "primary") {
                utils.weapons.pickUp(sandbox.defaultLoadout[0]);
                utils.weapons.switch();
                utils.weapons.pickUp(sandbox.defaultLoadout[1]);
              } else if (currentWeapon === "secondary") {
                utils.weapons.pickUp(sandbox.defaultLoadout[1]);
                utils.weapons.switch();
                utils.weapons.pickUp(sandbox.defaultLoadout[0]);
              }
              utils.weapons.switch("primary");
            }
            sandbox.loadout = utils.json.copy(sandbox.defaultLoadout);

            sandbox.primaryWeapon.alias.ammoCurrent = sandbox.primaryWeapon.alias.ammoCapacity;
            sandbox.primaryWeapon.alias.magazineCurrent = sandbox.primaryWeapon.alias.magazineCapacity;
            sandbox.secondaryWeapon.alias.ammoCurrent = sandbox.secondaryWeapon.alias.ammoCapacity;
            sandbox.secondaryWeapon.alias.magazineCurrent = sandbox.secondaryWeapon.alias.magazineCapacity;
            utils.weapons.switch("primary", initial);

            sandbox.grenades.current = sandbox.grenades.capacity;
            
            utils.health.increase(100);

            utils.camera.showUI();

            camera.fov = 60;
            camera.updateProjectionMatrix();

            let spawnPoints = sandbox.respawnPoints[sandbox.map];
            let spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            playerCollider.start.set(spawnPoint[0], spawnPoint[1] + 0.35, spawnPoint[2]);
            playerCollider.end.set(spawnPoint[0], spawnPoint[1] + 1, spawnPoint[2]);
            camera.rotation.set(spawnPoint[3], spawnPoint[4], spawnPoint[5]);

            gametime.run("playerRespawn", [gametime.player.uuid, (spawnPoint[0] + "," + spawnPoint[1] + "," + spawnPoint[2] + "," + spawnPoint[3] + "," + spawnPoint[4] + "," + spawnPoint[5]), initial]);
          }
        },
        medals: {
          earned: [],
          timeouts: {
            "kill": 0,
            "sniper_kill": 0,
            "no_scope": 0,
            "rocket_kill": 0,
            "grenade_kill": 0,
            "last_shot": 0,
            "headshot": 0
          },
          determine: function(headshot = false, grenade = false) {
            let result = {};

            result["kill"] = {
              points: 10,
              id: "kill",
              name: "Kill"
            };
            if (sandbox.currentWeapon.alias.ammoType === "sniper") {
              result["sniper_kill"] = {
                points: 5,
                id: "sniper_kill",
                name: "Sniper Kill"
              };
              if (!utils.options.get("Zoomed")) result["no_scope"] = {
                points: 10,
                id: "no_scope",
                name: "No Scope"
              };
            }
            if (sandbox.currentWeapon.alias.ammoType === "rocket") {
              result["rocket_kill"] = {
                points: 5,
                id: "rocket_kill",
                name: "Rocket Kill"
              };
            }
            if (grenade || sandbox.currentWeapon.alias.ammoType === "grenade") {
              result["grenade_kill"] = {
                points: 10,
                id: "grenade_kill",
                name: "Grenade Kill"
              };
            }
            if (sandbox.currentWeapon.alias.ammoCurrent <= 0) {
              result["last_shot"] = {
                points: 5,
                id: "last_shot",
                name: "Last Shot"
              };
            }
            if (headshot) {
              result["headshot"] = {
                points: 10,
                id: "headshot",
                name: "Headshot"
              };
            }

            Object.values(result).forEach(medal => utils.medals.earned.push(medal.id));
            return result;
          },
          display: function(headshot = false) {
            THREE.Sound("preloaded:playerkill", false);

            let medals = utils.medals.determine(headshot);
            let iteration = 0;
            let asyncIteration = 0;
            for (let i in medals) {
              let medal = medals[i];
              let medalId = btoa(Math.random().toString()).replace(/\=/gi, "");
            
              setTimeout(() => {
                if (asyncIteration > 0) THREE.Sound("preloaded:playerkillmedal", false);
            
                let activeMedals = utils.medals.getActive();
                if (activeMedals.includes(medal.id)) {
                  let medalElement = document.querySelector(`.medal[data-medal="${medal.id}"]`);
                  let multiplier = Number(medalElement.querySelector("#multiplier").dataset.multiplier) + 1;
                  medalElement.querySelector("#multiplier").dataset.multiplier = multiplier;
            
                  if (medal.id == "kill") {
                    if (multiplier == 2) {
                      medalElement.querySelector("#name").textContent = "Double Kill";
                      medalElement.querySelector(".medal-icon").src = "/images/icons/medals/double_kill.png";
                    } else if (multiplier == 3) {
                      medalElement.querySelector("#name").textContent = "Triple Kill";
                      medalElement.querySelector(".medal-icon").src = "/images/icons/medals/triple_kill.png";
                    } else {
                      medalElement.querySelector("#name").textContent = "Kill";
                      medalElement.querySelector(".medal-icon").src = "/images/icons/medals/kill.png";
                      medalElement.querySelector("#multiplier").textContent = `x${multiplier}`;
                    }
                  } else {
                    medalElement.querySelector("#multiplier").textContent = `x${multiplier}`;
                  }
            
                  utils.medals.setExpiration(medal.id);
                } else {
                  document.querySelector(".medal-wrapper").innerHTML += `
                  <div class="medal" id="medal-${medalId}" data-medal="${medal.id}" style="scale: 1.5"><img class="medal-icon" src="/images/icons/medals/${medal.id}.png"><span id="multiplier" data-multiplier="1"></span> <span id="name">${medal.name}</span></div>
                  `;
                  let medalElement = document.querySelector(`.medal#medal-${medalId}`);
                  new TWEEN.Tween(medalElement.style).to({ scale: 1 }, 100).easing(TWEEN.Easing.Quadratic.In).start();
                  utils.medals.setExpiration(medal.id);
                }
                asyncIteration++;
              }, iteration * 400);
            
              iteration++;
            }
          },
          displayGameOver: function() {
            let earnedMedals = utils.medals.getCurrent();
            earnedMedals.forEach((medal, index) => {
              setTimeout(() => {
                let medalId = btoa(Math.random().toString()).replace(/\=/gi, "");
                let activeMedals = utils.medals.getActive();
                if (activeMedals.includes(medal.id)) {
                  let medalElement = document.querySelector(`.medal[data-medal="${medal.id}"]`);
                  let multiplier = Number(medalElement.querySelector("#multiplier").dataset.multiplier) + 1;
                  medalElement.querySelector("#multiplier").dataset.multiplier = multiplier;
            
                  if (medal.id == "kill") {
                    if (multiplier == 2) {
                      medalElement.querySelector("#name").textContent = "Double Kill";
                      medalElement.querySelector(".medal-icon").src = "/images/icons/medals/double_kill.png";
                    } else if (multiplier == 3) {
                      medalElement.querySelector("#name").textContent = "Triple Kill";
                      medalElement.querySelector(".medal-icon").src = "/images/icons/medals/triple_kill.png";
                    } else {
                      medalElement.querySelector("#name").textContent = "Kill";
                      medalElement.querySelector(".medal-icon").src = "/images/icons/medals/kill.png";
                      medalElement.querySelector("#multiplier").textContent = `x${multiplier}`;
                    }
                  } else {
                    medalElement.querySelector("#multiplier").textContent = `x${multiplier}`;
                  }
                } else {
                  document.querySelector(".earned-medals").innerHTML += `
                  <div class="medal ignore" id="medal-${medalId}" data-medal="${medal.id}" style="scale: 1.5"><img class="medal-icon ignore" src="/images/icons/medals/${medal.id}.png"><span class="ignore" id="multiplier" data-multiplier="1"></span> <span class="ignore" id="name">${medal.name}</span></div>
                  `;
                  let medalElement = document.querySelector(`.medal#medal-${medalId}`);
                  new TWEEN.Tween(medalElement.style).to({ scale: 1 }, 100).easing(TWEEN.Easing.Quadratic.In).start();
                }
              }, index * 500);
            });
          },
          setExpiration: function(medal) {
            clearTimeout(utils.medals.timeouts[medal]);

            let expire = setTimeout(function() {
              document.querySelector(`.medal[data-medal="${medal}"]`).remove();
            }, 5000);

            utils.medals.timeouts[medal] = expire;
          },
          getActive: function() {
            let medals = Object.values(document.querySelectorAll(".medal")).map(x => x.dataset.medal);
            return medals;
          },
          getCurrent: function() {
            return utils.medals.earned;
          }
        }
      };

      sandbox.loadout = utils.json.copy(sandbox.defaultLoadout);

      // Load all of the default models
      utils.loadingManager.onProgress = function(url, itemsLoaded, itemsTotal) {
        const progress = itemsLoaded / itemsTotal;
        // console.log(`Loading file: ${url}, ${(progress * 100).toFixed(2)}% loaded`);
        if (progress >= 1) {
          setup();
        }
      };
      Object.keys(sandbox.models).forEach(model => {
        load(sandbox.models[model].path, function(gltf) {
          sandbox.models[model].model = gltf.scene;
          sandbox.models[model].callback(gltf);
          if (gltf.animations) {
            sandbox.models[model].animations = gltf.animations;
            sandbox.models[model].mixer = new THREE.AnimationMixer(gltf.scene);
          }
          if (model.startsWith("weapon_") && sandbox.models[model].name === sandbox.loadout[0]) {
            utils.weapons.setPrimary(sandbox.models[model].model);
            utils.weapons.switch("primary", true);
          }
          if (model.startsWith("weapon_") && sandbox.models[model].name === sandbox.loadout[1]) {
            utils.weapons.setSecondary(sandbox.models[model].model);
          }

          sandbox.models[model].loaded = true;
        });
      });
      async function reloadModel(model) {
        return new Promise(function(resolve) {
          new THREE.GLTFLoader().load(sandbox.models[model].path, function(gltf) {
            let result = {};
            result.model = gltf.scene;
            sandbox.models[model].callback(gltf);
            if (gltf.animations) {
              result.animations = gltf.animations;
              result.mixer = new THREE.AnimationMixer(gltf.scene);
            }
            resolve(result);
          });
        });
      }
      
      // Preload audio files here
      for (weapon in sandbox.weapons) {
        THREE.Sound.preload(`shooting_${sandbox.weapons[weapon].name}`, `/sounds/weapons/shooting/${sandbox.weapons[weapon].name}.mp3`);
        THREE.Sound.preload3d(`shooting3d_${sandbox.weapons[weapon].name}`, `/sounds/weapons/shooting/${sandbox.weapons[weapon].name}.mp3`);
        THREE.Sound.preload(`reloading_${sandbox.weapons[weapon].name}`, `/sounds/weapons/reloading/normal.${sandbox.weapons[weapon].name}.mp3`);
        THREE.Sound.preload(`reloadingfull_${sandbox.weapons[weapon].name}`, `/sounds/weapons/reloading/full.${sandbox.weapons[weapon].name}.mp3`);
      }
      THREE.Sound.preload3d(`grenadeexplosion_Frag`, `/sounds/weapons/grenades/Frag.mp3`);
      THREE.Sound.preload3d(`grenadericochet1`, `/sounds/weapons/grenades/Ricochet1.mp3`);
      THREE.Sound.preload3d(`grenadericochet2`, `/sounds/weapons/grenades/Ricochet2.mp3`);
      THREE.Sound.preload3d(`grenadericochet3`, `/sounds/weapons/grenades/Ricochet3.mp3`);
      THREE.Sound.preload3d(`grenadericochet4`, `/sounds/weapons/grenades/Ricochet4.mp3`);
      THREE.Sound.preload3d(`grenadetoss3d`, `/sounds/weapons/grenades/Toss.mp3`);
      THREE.Sound.preload(`grenadetoss`, `/sounds/weapons/grenades/Toss.mp3`);
      THREE.Sound.preload(`playerhit`, `/sounds/fx/hit.mp3`);
      THREE.Sound.preload(`playerkill`, `/sounds/fx/kill.mp3`);
      THREE.Sound.preload(`playerkillmedal`, `/sounds/fx/kill-medal.mp3`);
      THREE.Sound.preload(`zooming_scope_in`, `/sounds/weapons/zooming/scope-in.mp3`);
      THREE.Sound.preload(`zooming_scope_out`, `/sounds/weapons/zooming/scope-out.mp3`);
      THREE.Sound.preload(`zooming_precision_in`, `/sounds/weapons/zooming/precision-in.mp3`);
      THREE.Sound.preload(`zooming_precision_out`, `/sounds/weapons/zooming/precision-out.mp3`);
      THREE.Sound.preload(`weapon_drop`, `/sounds/weapons/other/drop.mp3`);
      THREE.Sound.preload(`weapon_switch_primary`, `/sounds/weapons/other/switch-primary.mp3`);
      THREE.Sound.preload(`weapon_switch_secondary`, `/sounds/weapons/other/switch-secondary.mp3`);
      THREE.Sound.preload(`weapon_melee`, `/sounds/weapons/other/melee.mp3`);
      THREE.Sound.preload(`weapon_magazine_pickup`, `/sounds/weapons/other/magazine-pickup.mp3`);
      THREE.Sound.preload(`weapon_walking`, `/sounds/fx/walking.mp3`);
      THREE.Sound.preload(`weapon_running`, `/sounds/fx/running.mp3`);
      THREE.Sound.preload(`countdowntimer`, `/sounds/menu/timer.mp3`);
      THREE.Sound.preload(`menu_gameover`, `/sounds/menu/game_over.mp3`);

      // Set all default options here
      utils.options.set("TouchDevice", window.matchMedia("(pointer: coarse)").matches);
      utils.options.set("StopShooting", false);
      utils.options.set("Reloading", false);
      utils.options.set("TriggerCooldown", false);
      utils.options.set("CancelReload", false);
      utils.options.set("Walking", false);
      utils.options.set("Running", false);
      utils.options.set("Shooting", false);
      utils.options.set("AimingAtPlayer", false);
      utils.options.set("AutoLock", false);
      utils.options.set("Health", 100);
      utils.options.set("Strength", 100);
      utils.options.set("CameraLocked", true);
      utils.options.set("ThrowingGrenade", false);
      utils.options.set("DoingRicochet", false);
      utils.options.set("CameraTurning", false);
      utils.options.set("Dying", false);
      utils.options.set("ObjectsRendered", false);
      utils.options.set("SetupComplete", false);
      utils.options.set("CancelingRun", false);
      utils.options.set("Melee", false);
      utils.options.set("CameraShaking", false);
      utils.options.set("CancelCameraShake", false);
      utils.options.set("Zoomed", false);
      utils.options.set("Zooming", false);

      // Cache everything else needed here
      utils.cache.publish("bulletHole");
      [...new Set(Object.values(sandbox.weapons).map(weapon => weapon.ammoType))].forEach(ammoType => {
        let texturePath = `/images/assets/bullet-holes/${ammoType}/1.png`;
        const bulletHoleTexture = new THREE.TextureLoader().load(texturePath);
        utils.cache.write("bulletHole", ammoType, bulletHoleTexture);
      });
      utils.cache.write("bulletHole", "spark", new THREE.TextureLoader().load("/images/assets/spark.png"));
      utils.cache.publish("raycaster");
      utils.cache.write("raycaster", "main", new THREE.Raycaster());
      utils.cache.write("raycaster", "center", new THREE.Vector2(0, 0));
      utils.cache.write("raycaster", "aimingObjects", []);
      utils.cache.publish("health");
      utils.cache.write("health", "incrementTimeout", 0);
      utils.cache.write("health", "incrementInterval", 0);
      utils.cache.publish("deathPose");
      load("/models/characters/death-poses/SWAT.glb", function(gltf) {
        let model = gltf.scene;
        utils.cache.write("deathPose", "SWAT", model);
      });
      utils.cache.publish("explosionLight");
      utils.cache.write("explosionLight", "main", new THREE.PointLight(0xd75300, 1, 10));
      utils.cache.write("explosionLight", "clone", new THREE.PointLight(0xd75300, 1, 5));
      utils.cache.publish("outlines");
      utils.cache.write("outlines", "saved", {});
      utils.cache.publish("garbage");
      utils.cache.write("garbage", "runTween", new TWEEN.Tween());
      utils.cache.write("garbage", "runStopTween", new TWEEN.Tween());
      utils.cache.write("garbage", "previousRunDepletion", Date.now());
      utils.cache.write("garbage", "rocketReloadPositionTween", new TWEEN.Tween());
      utils.cache.write("garbage", "rocketReloadRotationTween", new TWEEN.Tween());
      utils.cache.write("garbage", "zoomOutPositionTween", new TWEEN.Tween());
      utils.cache.write("garbage", "zoomOutRotationTween", new TWEEN.Tween());
      utils.cache.write("garbage", "zoomOutCameraTween", new TWEEN.Tween());
      utils.cache.write("garbage", "zoomOutWeaponCameraTween", new TWEEN.Tween());
      utils.cache.write("garbage", "zoomInPositionTween", new TWEEN.Tween());
      utils.cache.write("garbage", "zoomInRotationTween", new TWEEN.Tween());
      utils.cache.write("garbage", "zoomInCameraTween", new TWEEN.Tween());
      utils.cache.write("garbage", "zoomInWeaponCameraTween", new TWEEN.Tween());
      utils.cache.write("garbage", "muzzleFlash", new THREE.Mesh(new THREE.CircleGeometry(1, 16), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("/images/assets/muzzle-flash.png"), transparent: true, depthTest: false })));
      scene.add(utils.cache.read("garbage", "muzzleFlash"));
      utils.cache.read("garbage", "muzzleFlash").visible = false;
      utils.cache.read("garbage", "muzzleFlash").layers.set(1);
      utils.cache.read("garbage", "muzzleFlash").scale.set(1, 0.6, 1);

      // Global functions go here
      function update() {
        renderer.shadowMap.needsUpdate = true;
      }
      function load(url, callback) {
        if (Object.keys(utils.cache.models).indexOf(url) > -1) return callback(utils.cache.models[url]);
        new THREE.GLTFLoader(utils.loadingManager).load(url, function(model) {
          utils.cache.models[url] = model;
          callback(model);
        });
      }
      function getForwardVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        return playerDirection;
      }
      function getSideVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        playerDirection.cross(camera.up);
        return playerDirection;
      }
      function controls(deltaTime) {
        if (keyStates[keyBindings.sprint] && utils.options.get("Running") && !utils.options.get("Reloading") && !utils.options.get("Melee")) {
          if (utils.strength.getCurrent() <= 0) {
            utils.strength.set(0);
            utils.weapons.cancelRun();
          } else {
            utils.strength.decrement(0.6);
          }
          utils.cache.write("garbage", "previousRunDepletion", Date.now());
        } else {
          if (Date.now() - utils.cache.read("garbage", "previousRunDepletion") >= 5000) {
            if (utils.strength.getCurrent() >= 100) {
              utils.strength.set(100);
            } else {
              utils.strength.increment(0.3);
            }
          }
        }
        if (!utils.options.get("CancelingRun") && !utils.options.get("Reloading") && utils.options.get("Walking") && keyStates[keyBindings.walkforward] && keyStates[keyBindings.sprint] && !utils.options.get("Running") && !utils.options.get("Zoomed")) {
          sandbox.currentWeapon.alias.animationStructure["walk"][1] *= 3;

          THREE.Sound.stop("preloaded:weapon_walking", "walking");
          utils.camera.stopShake();

          THREE.Sound("preloaded:weapon_running", false, null, () => {}, 0, 0, true, true, "running");
          utils.camera.shake(0.2, 100, true);

          utils.weapons.stopAnimation("walk");
          utils.weapons.playAnimation("walk");
          utils.weapons.playAnimation("run");

          utils.options.set("Running", true);
        }
        if (!keyStates[keyBindings.sprint] && utils.options.get("Running")) {
          sandbox.currentWeapon.alias.animationStructure["walk"][1] /= 3;
          utils.options.set("Running", false);
          THREE.Sound.stop("preloaded:weapon_running", "running");
          utils.camera.stopShake();
          utils.weapons.stopAnimation("run");

          if (utils.options.get("Walking")) {
            THREE.Sound("preloaded:weapon_walking", false, null, () => {}, 0, 0, true, true, "walking");
            utils.weapons.playAnimation("walk");
            if (!utils.options.get("Zoomed")) utils.camera.shake(0.2, 200, true);
          }
        }

        if (!PointerControls.isLocked) return;
        const speedDelta = deltaTime;
        const walkSpeed = (deltaTime * (playerOnFloor ? 15 : 2)) * (utils.options.get("Running") ? 2 : 1);
        if (keyStates[keyBindings.walkforward] || keyStates["ArrowUp"] || keyStates[keyBindings.walkleft] || keyStates["ArrowLeft"] || keyStates[keyBindings.walkbackward] || keyStates["ArrowDown"] || keyStates[keyBindings.walkright] || keyStates["ArrowRight"]) {
          // Here you can run a function whenever the player walks/moves
          gametime.run("move", [gametime.player.uuid, "fixed", (camera.position.x + "," + camera.position.y + "," + camera.position.z), true]);
        }
        if (keyStates[keyBindings.walkforward] || keyStates["ArrowUp"]) {
          playerVelocity.add(getForwardVector().multiplyScalar(walkSpeed));
        }
        if (keyStates[keyBindings.walkbackward] || keyStates["ArrowDown"]) {
          playerVelocity.add(getForwardVector().multiplyScalar(-walkSpeed));
        }
        if (keyStates[keyBindings.walkleft] || keyStates["ArrowLeft"]) {
          playerVelocity.add(getSideVector().multiplyScalar(-walkSpeed));
        }
        if (keyStates[keyBindings.walkright] || keyStates["ArrowRight"]) {
          playerVelocity.add(getSideVector().multiplyScalar(walkSpeed));
        }
        if (playerOnFloor) {
          if (keyStates[keyBindings.jump] && allowedToJump) {
            gametime.run("jump", [gametime.player.uuid]);
            allowedToJump = false;
            playerVelocity.y = 8;
            THREE.Sound.stop("preloaded:weapon_walking", "walking");
            THREE.Sound.stop("preloaded:weapon_running", "running");
            utils.camera.stopShake();
            utils.camera.shake(0.5, 300);
            setTimeout(() => allowedToJump = true, 1000);
            setTimeout(() => {
              plugins.waitUntil(() => playerOnFloor).then(() => {
                if (utils.options.get("Walking")) {
                  if (utils.options.get("Running")) {
                    THREE.Sound("preloaded:weapon_running", false, null, () => {}, 0, 0, true, true, "running");
                    if (!utils.options.get("Zoomed")) utils.camera.shake(0.2, 100, true);
                  } else {
                    THREE.Sound("preloaded:weapon_walking", false, null, () => {}, 0, 0, true, true, "walking");
                    if (!utils.options.get("Zoomed")) utils.camera.shake(0.2, 200, true);
                  }
                }
              });
            }, 50);
          }
        }
      }
      function playerCollisions() {
        const result = worldOctree.capsuleIntersect(playerCollider);
        playerOnFloor = false;
        if (result) {
          playerOnFloor = result.normal.y > 0;
          if (!playerOnFloor) {
            playerVelocity.addScaledVector(result.normal, - result.normal.dot(playerVelocity));
          }
          playerCollider.translate(result.normal.multiplyScalar(result.depth));
        }
      }
      function updatePlayer(deltaTime) {
        let damping = Math.exp(-4 * deltaTime) - 1;
        if (!playerOnFloor) {
          playerVelocity.y -= GRAVITY * (deltaTime);
          damping *= 0.1;
        }
        playerVelocity.addScaledVector(playerVelocity, damping);
        const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
        playerCollider.translate(deltaPosition);
        playerCollisions();
        if (utils.options.get("CameraLocked")) camera.position.copy(playerCollider.end);
      }
      function updateGrenades(deltaTime) {
        for (let i = 0; i < grenades.length; i++) {
          let grenade = grenades[i];

          grenade.mesh.rotation.x += grenade.angularVelocity.x * deltaTime;
          grenade.mesh.rotation.y += grenade.angularVelocity.y * deltaTime;
          grenade.mesh.rotation.z += grenade.angularVelocity.z * deltaTime;

          grenade.collider.center.addScaledVector(grenade.velocity, deltaTime);
          const result = worldOctree.sphereIntersect(grenade.collider);
          if (result) {
            grenade.hits++;
            grenade.velocity.addScaledVector(result.normal, -result.normal.dot(grenade.velocity) * 1.5);

            const rotationAxis = new THREE.Vector3().crossVectors(result.normal, grenade.velocity).normalize();
            const rotationSpeed = grenade.velocity.length() * 0.5;
            grenade.angularVelocity.addScaledVector(rotationAxis, rotationSpeed);

            grenade.collider.center.add(result.normal.multiplyScalar(result.depth));

            if (result.depth > 0.03) utils.weapons.grenades.ricochet(grenade);
            if (grenade.hits == 1 && grenade.explode) {
              utils.weapons.grenades.explosion(grenade.mesh, i, 2000, true, grenade.uuid);
              gametime.run("move", [gametime.player.uuid, "fixed", (camera.position.x + "," + camera.position.y + "," + camera.position.z), true]);
            }
          } else {
            grenade.velocity.y -= (GRAVITY * deltaTime + .01);
          }
          const damping = Math.exp(deltaTime * -1.5) - 1.003;
          grenade.velocity.addScaledVector(grenade.velocity, damping);
          grenade.angularVelocity.addScaledVector(grenade.angularVelocity, damping);
        }
        grenadeCollisions();
        for (let grenade of grenades) {
          grenade.mesh.position.copy(grenade.collider.center);
        }
      }
      function grenadeCollisions() {
        for (let i = 0, length = grenades.length; i < length; i++) {
          const s1 = grenades[i];
          for (let j = i + 1; j < length; j++) {
            const s2 = grenades[j];
            const d2 = s1.collider.center.distanceToSquared(s2.collider.center);
            const r = s1.collider.radius + s2.collider.radius;
            const r2 = r * r;
            if (d2 < r2) {
              const normal = _vector1.subVectors(s1.collider.center, s2.collider.center).normalize();
              const v1 = _vector2.copy(normal).multiplyScalar(normal.dot(s1.velocity));
              const v2 = _vector3.copy(normal).multiplyScalar(normal.dot(s2.velocity));
              s1.velocity.add(v2).sub(v1);
              s2.velocity.add(v1).sub(v2);
              const d = (r - Math.sqrt(d2)) / 2;
              s1.collider.center.addScaledVector(normal, d);
              s2.collider.center.addScaledVector(normal, - d);
            }
          }
        }
      }
      function teleportPlayerIfOob() {
        if (camera.position.y <= -25) {
          playerCollider.start.set(13.5, 0.35, -18.5);
          playerCollider.end.set(13.5, 1, -18.5);
          playerCollider.radius = 0.35;
          camera.position.copy(playerCollider.end);
          camera.rotation.set(0, Math.PI, 0);
        }
      }

      // Global events go here
      function onWindowResize() {
        renderer.setViewport(0, 0, (1440 / 2) + 80, (900 / 2) + 50);
        weaponRenderer.setViewport(0, 0, (1440 / 2) + 80, (900 / 2) + 50);

        let averageScale = window.innerHeight / 900;
        let minWidth = 1440 * averageScale;
        if (window.innerWidth < minWidth) {
          // Scale the UI based on the width of window
          document.querySelector(".ui").style.transform="scale(" + (window.innerWidth/1440) + ")";
        } else {
          // Scale the UI based on the height of window
          document.querySelector(".ui").style.transform="scale(" + (window.innerHeight/900) + ")";
        }
      }
      window.addEventListener("resize", onWindowResize);
      onWindowResize();

      let stoppedWalking = true;
      let globalRepeat = false;
      let shootRapid = false;
      document.addEventListener("keydown", (event) => {
        if (!PointerControls.isLocked) return;
        keyStates[event.code] = true;
        keyRepeats[event.code] = event.repeat;

        if (!event.repeat && !globalRepeat && (keyStates[keyBindings.walkforward] || keyStates["ArrowUp"] || keyStates[keyBindings.walkleft] || keyStates["ArrowLeft"] || keyStates[keyBindings.walkbackward] || keyStates["ArrowDown"] || keyStates[keyBindings.walkright] || keyStates["ArrowRight"])) {
          stoppedWalking = false;
          utils.options.set("Walking", true);
          if (!utils.options.get("Reloading") && !utils.options.get("Shooting")) utils.weapons.playAnimation("walk");
          THREE.Sound("preloaded:weapon_walking", false, null, () => {}, 0, 0, true, true, "walking");
          if (!utils.options.get("Zoomed")) utils.camera.shake(0.2, 200, true);
        }
        if (!event.repeat && keyStates[keyBindings.zoom]) utils.weapons.zoom();

        if (keyStates[keyBindings.shoot] && !shootRapid) {
          shootRapid = true;
          utils.weapons.shoot(event.repeat);
        }

        if (!event.repeat && keyStates[keyBindings.reload]) {
          utils.weapons.reload();
        }

        if (!event.repeat && keyStates[keyBindings.switchweapon]) {
          utils.weapons.switch();
        }

        if (!event.repeat && keyStates[keyBindings.throwgrenade]) {
          utils.weapons.grenades.throw();
        }

        if (!event.repeat && keyStates[keyBindings.melee]) {
          utils.weapons.melee();
        }

        globalRepeat = true;
      });

      document.addEventListener("keyup", (event) => {
        globalRepeat = false;
        keyStates[event.code] = false;
        keyRepeats[event.code] = false;

        // Since the other players do not receive effects like air resistance, we will update the players' position briefly after they stop walking
        let updatePosition = setInterval(function() {
          gametime.run("move", [gametime.player.uuid, "fixed", (camera.position.x + "," + camera.position.y + "," + camera.position.z), false]);
        }, 10);
        setTimeout(function() {
          clearInterval(updatePosition);
          gametime.run("halt", [gametime.player.uuid]);
        }, 1000);

        if (!stoppedWalking && !(keyStates[keyBindings.walkforward] || keyStates["ArrowUp"] || keyStates[keyBindings.walkleft] || keyStates["ArrowLeft"] || keyStates[keyBindings.walkbackward] || keyStates["ArrowDown"] || keyStates[keyBindings.walkright] || keyStates["ArrowRight"])) {
          stoppedWalking = true;
          utils.options.set("Walking", false);
          THREE.Sound.stop("preloaded:weapon_walking", "walking");
          utils.weapons.stopAnimation("walk");
          utils.camera.stopShake();

          gametime.run("halt", [gametime.player.uuid]);
        }

        if (event.code === keyBindings.shoot) {
          if (shootRapid) {
            utils.weapons.stopShoot();
          }
          shootRapid = false;
        }
      });

      document.addEventListener("mousemove", (event) => {
        if (!PointerControls.isLocked) return;
        if (document.querySelector(".loading-screen") && document.querySelector(".loading-screen").contains(event.target)) return;
        gametime.run("rotate", [gametime.player.uuid, (camera.rotation.x + "," + camera.rotation.y + "," + camera.rotation.z + "," + camera.position.x + "," + camera.position.y + "," + camera.position.z)]);
      });

      document.addEventListener("touchmove", (event) => {
        gametime.run("rotate", [gametime.player.uuid, (camera.rotation.x + "," + camera.rotation.y + "," + camera.rotation.z + "," + camera.position.x + "," + camera.position.y + "," + camera.position.z)]);
      });

      document.addEventListener("mousedown", (event) => {
        if (document.pointerLockElement != null) return;
        if (document.querySelector(".loading-screen") && document.querySelector(".loading-screen").contains(event.target)) return;
        document.body.requestPointerLock();
        PointerControls.lock();
      });

      document.addEventListener("mouseup", (event) => {
        if (!PointerControls.isLocked) return;
        if (document.querySelector(".loading-screen") && document.querySelector(".loading-screen").contains(event.target)) return;
        PointerControls.lock();
      });

      load(`models/maps/${sandbox.map}.glb`, (model) => {
        map = model.scene;

        // This can significantly improve performance
        map.traverse(object => object.frustumCulled = false);

        worldOctree.fromGraphNode(map);
        scene.add(map);
        map.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            if (child.material.map) {
              child.material.map.anisotropy = 4;
            }
          }
        });

        // If the map has any metadata, it will be extracted and used here
        if (map.children[0] && map.children[0].userData.sky && map.children[0].userData.sky != "none") {
          new THREE.TextureLoader().load(`/images/other/sky/${map.children[0].userData.sky}.png`, function(texture) {
            let sky = new THREE.Mesh(new THREE.SphereGeometry(100, 25, 25), new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide }));
            sky.material.side = THREE.BackSide;
            scene.add(sky);
          });
        }
        if (map.children[0] && map.children[0].userData.lightColor && map.children[0].userData.lightColor != "none") {
          directionalLight.color = new THREE.Color(map.children[0].userData.lightColor);
        }
        if (map.children[0] && map.children[0].userData.ambience && map.children[0].userData.ambience != "none") {
          THREE.Sound.preload("map_ambience", `/sounds/fx/ambience/${map.children[0].userData.ambience}.mp3`);
        }

        animate();
        update();
      });

      // Game setup goes here (functions that run when the game starts)
      function setup() {
        // Load additional objects here
        loadGrenades();

        window.LoadingManager.onfinish = function() {
          // Let other players know this player's presence
          let character = params().character || "SWAT";
          gametime.run("join", [gametime.player.position, gametime.player.uuid, character, sandbox.username]);
        };

        window.LoadingManager.oncountdown = function() {
          // Here is where the initial countdown is shown
          weaponScene.remove(sandbox.currentWeapon);
          utils.camera.hideUI(false, true);
          let secondsLeft = 10;
          let countdown = plugins.realInterval(function() {
            if (secondsLeft <= 0) return plugins.clearRealInterval(countdown), gameStart();
            if (secondsLeft <= 3) THREE.Sound("preloaded:countdowntimer", false);
            document.querySelector(".clock .countdown-seconds").textContent = secondsLeft;

            secondsLeft--;
          }, 1000);

          // Play background (ambience) noises
          THREE.Sound("preloaded:map_ambience", false, null, () => {}, 0, 0, true);
        };

        // Set the initial spawn for the player
        utils.health.respawn(true);

        // Spawn the map's weapons and assets here
        if (sandbox.map === "Cargo_Port") {
          utils.weapons.spawn("Railgun",new THREE.Vector3(6.1,0,3.2),new THREE.Vector3(0,0,0));
          utils.weapons.spawn("Barrett-50cal",new THREE.Vector3(15.5,0,6.8),new THREE.Vector3(0,0,0));
          utils.weapons.spawn("AR-15",new THREE.Vector3(22.6,0,13.9),new THREE.Vector3(0,-Math.PI/2,0));
          utils.weapons.spawn("HK-G28",new THREE.Vector3(0.8,0,15),new THREE.Vector3(0,Math.PI,0));
          utils.weapons.spawn("Railgun",new THREE.Vector3(-9.3,0,-1.7),new THREE.Vector3(0,Math.PI/2,0));
          utils.weapons.spawn("Rocket-Launcher",new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,0));
          utils.weapons.spawn("Desert-Eagle",new THREE.Vector3(-9.3,0,-18.6),new THREE.Vector3(0,Math.PI/2,0));
          utils.weapons.spawn("Remington-870",new THREE.Vector3(11.3,0,-18.6),new THREE.Vector3(0,Math.PI/2,0));
          utils.weapons.spawn("Glock-19",new THREE.Vector3(9.6,0,-6.2),new THREE.Vector3(0,Math.PI/2,0));
          utils.effects.outline.add(map);
        } else if (sandbox.map === "Lihid") {
          utils.weapons.spawn("RPG-7",new THREE.Vector3(-27.7,-1.5,-14.3),new THREE.Vector3(0,Math.PI/2,0));
          utils.weapons.spawn("AR-15",new THREE.Vector3(-20.7,-1.5,-22.6),new THREE.Vector3(0,Math.PI,0));
          utils.weapons.spawn("AR-15",new THREE.Vector3(-28.6,-1,-1.6),new THREE.Vector3(0,Math.PI/2,0));
          utils.weapons.spawn("Grenade-Launcher",new THREE.Vector3(-9.6,-3,-2.9),new THREE.Vector3(0,0,0));
          utils.weapons.spawn("Desert-Eagle",new THREE.Vector3(-1.9,-1.5,10.4),new THREE.Vector3(0,Math.PI,0));
          utils.weapons.spawn("M40a3",new THREE.Vector3(4.4,-1.5,24.9),new THREE.Vector3(0,-Math.PI/2,0));
          utils.weapons.spawn("Barrett-50cal",new THREE.Vector3(-20.8,0.2,17.4),new THREE.Vector3(0,0,0));
          utils.weapons.spawn("Barrett-50cal",new THREE.Vector3(-19.5,-1,6.5),new THREE.Vector3(0,-Math.PI/2,0));
          utils.weapons.spawn("AK-74",new THREE.Vector3(6,-3.2,-17.3),new THREE.Vector3(0,-Math.PI/2,0));
          utils.weapons.spawn("Grenade-Launcher",new THREE.Vector3(4.6,-0.2,-21.5),new THREE.Vector3(0,0,0));
          utils.weapons.spawn("Railgun",new THREE.Vector3(22.8,-0.6,7.2),new THREE.Vector3(0,-Math.PI/2,0));
          utils.effects.outline.add(map);
        } else if (sandbox.map === "Ghost_Town") {
          utils.weapons.spawn("Rocket-Launcher",new THREE.Vector3(42.3, -0.1, -9),new THREE.Vector3(0,0,0));
          utils.weapons.spawn("Rocket-Launcher",new THREE.Vector3(34.7, -1.4, 22.9),new THREE.Vector3(0,-Math.PI/2,0));
          utils.weapons.spawn("RPG-7",new THREE.Vector3(38.5, -1.4, 13.4),new THREE.Vector3(0,0,0));
          utils.weapons.spawn("Barrett-50cal",new THREE.Vector3(49.3, 0, -2.8),new THREE.Vector3(0,Math.PI,0));
          utils.weapons.spawn("Desert-Eagle",new THREE.Vector3(49.1, 0, -11.3),new THREE.Vector3(0,0,0));
          utils.weapons.spawn("HK-G28",new THREE.Vector3(62.6, 0, -11.3),new THREE.Vector3(0,0,0));
          utils.weapons.spawn("HK-G28",new THREE.Vector3(65.6, -0.1, -14.7),new THREE.Vector3(0,0,0));
          utils.weapons.spawn("HK-G28",new THREE.Vector3(18.6, 0, -3.7),new THREE.Vector3(0,Math.PI,0)); 
          utils.weapons.spawn("Grenade-Launcher",new THREE.Vector3(16.3, -0.1, -13.1),new THREE.Vector3(0,-Math.PI/2,0)); 
          utils.effects.outline.add(map);
        } else if (sandbox.map === "Breakthrough") {
          utils.weapons.spawn("M40a3",new THREE.Vector3(19.2, 2.1, 5.4),new THREE.Vector3(0,-Math.PI/2,0));
          utils.weapons.spawn("AR-15",new THREE.Vector3(5, 2.1, 5.4),new THREE.Vector3(0,Math.PI/2,0));
          utils.weapons.spawn("Grenade-Launcher",new THREE.Vector3(8.2, 0, -9.3),new THREE.Vector3(0,Math.PI/2,0));
          utils.weapons.spawn("HK-G28",new THREE.Vector3(14.5, 2, -7.6),new THREE.Vector3(0,Math.PI,0));
          utils.weapons.spawn("M40a3",new THREE.Vector3(4.3, 2.1, -23.1),new THREE.Vector3(0,Math.PI/2,0));
          utils.weapons.spawn("AR-15",new THREE.Vector3(10.8, 2.1, -21.9),new THREE.Vector3(0,Math.PI,0));
          utils.effects.outline.add(map);
        } else if (sandbox.map === "Abandoned_City") {
          utils.effects.outline.add(map);
        }

        utils.options.set("SetupComplete", true);
      }

      function gameStart() {
        // Start the game here
        window.LoadingManager.remove();
        utils.weapons.switch("primary");
        utils.camera.showUI();
        if (utils.options.get("TouchDevice")) PointerControls.isLocked = true;
      }

      async function gameEnd() {
        // End the game here
        utils.camera.hideUI(false, false);
        sandbox.presets.animationSpeed = 1/4;
        PointerControls.pointerSpeed /= 4;
        TouchControls.speed /= 4;
        PointerControls.isLocked = false;
        TouchControls.isLocked = false;
        for (i in keyStates) {
          keyStates[i] = false;
        }

        await plugins.realDelay(2000);

        let sound0 = false;
        let styling = {
          top: 150
        };
        document.querySelector(".game-over-banner").style.display = "block";
        document.querySelector(".game-over-banner").style.opacity = 0;
        await plugins.realDelay(250);
        document.querySelector(".game-over-banner .header").style.top = "150%";
        new TWEEN.Tween(document.querySelector(".game-over-banner").style).to({ opacity: 1 }, 300).easing(TWEEN.Easing.Quadratic.In).start();
        new TWEEN.Tween(styling).to({ top: 0 }, 750).easing(TWEEN.Easing.Quadratic.In).start().onUpdate(function() {
          document.querySelector(".game-over-banner .header").style.top = styling.top + "%";
          if (styling.top <= 100 && !sound0) {
            sound0 = true;
            THREE.Sound(`preloaded:menu_gameover`, false);
          }
        });

        await plugins.realDelay(2000);

        let topTeams = utils.scoreboard.topTeam();
        if (topTeams.includes(sandbox.username) && topTeams.length === 1) {
          document.querySelector(".game-over-status").innerHTML = `<i class="fa fa-trophy ignore"></i> VICTORY <i class="fa fa-trophy ignore"></i>`;
        } else if (topTeams.includes(sandbox.username)) {
          document.querySelector(".game-over-status").innerHTML = `<i class="fa fa-trophy ignore"></i> TIE <i class="fa fa-trophy ignore"></i>`;
        } else {
          document.querySelector(".game-over-status").innerHTML = `DEFEAT`;
        }
        document.querySelector(".game-over-status").style.visibility = "visible";

        await plugins.realDelay(2000);

        utils.medals.displayGameOver();

        await plugins.realDelay(1500);

        let totalMedals = utils.medals.earned.map(medal => medal.points);
        if (totalMedals.length === 0) totalMedals.push(0);
        let totalPoints = totalMedals.reduce((a, b) => a + b);

        document.querySelector(".total-points #value").textContent = totalPoints;
        document.querySelector(".total-points").style.visibility = "visible";

        await plugins.realDelay(17000);

        let earnings = {};
        earnings.medals = utils.medals.earned.map(medal => medal.id);
        earnings.points = totalPoints;

        localStorage.setItem("game-over-earnings", JSON.stringify(earnings));
        location.replace("/");
      }
      
      // Screen controls
      const PointerControls = new PointerLockControls(camera, renderer.domElement);
      const TouchControls = new THREE.TouchControls(camera, renderer.domElement);
      PointerControls.pointerSpeed = user.preferences.game.mouseSpeed || 2;
      PointerControls.isLocked = false;
      TouchControls.speed = user.preferences.game.touchSpeed || 2;
      GamepadControls.speed = user.preferences.game.gamepadSpeed || 1;
      screenControls = [PointerControls, TouchControls];
      PointerControls.minPolarAngle = Math.PI / 2 - THREE.MathUtils.degToRad(80);
      PointerControls.maxPolarAngle = Math.PI / 2 + THREE.MathUtils.degToRad(80);
      // screenControls.forEach(controls => controls.isLocked = true);

      // Here, we'll set up a touch screen UI
      let repeat = false;
      let defaultKeys = { code: keyBindings.sprint, key: "Shift" };
      const TouchUI = new UI("touch", function(type, parameters) {
        if (type == "move") {
          if (parameters.positive) {
            if (parameters.where == "forward") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.walkforward, key: "w" }));
              if (parameters.run) {
                !defaultKeys.repeat && document.dispatchEvent(new KeyboardEvent("keydown", defaultKeys));
                defaultKeys.repeat = true;
              } else {
                defaultKeys.repeat = false;
                document.dispatchEvent(new KeyboardEvent("keyup", defaultKeys));
              }
            } else if (parameters.where == "forward") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.walkforward, key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkleft, key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkbackward, key: "s" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkright, key: "d" }));
            } else if (parameters.where == "forward-right") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.walkforward, key: "w" })), document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.walkright, key: "d" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkleft, key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkbackward, key: "s" }));
            } else if (parameters.where == "right") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.walkright, key: "d" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkforward, key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkleft, key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkbackward, key: "s" }));
            } else if (parameters.where == "backward-right") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.walkbackward, key: "s" })), document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.walkright, key: "d" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkforward, key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkleft, key: "a" }));
            } else if (parameters.where == "backward") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.walkbackward, key: "s" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkforward, key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkleft, key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkright, key: "d" }));
            } else if (parameters.where == "backward-left") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.walkbackward, key: "s" })), document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.walkleft, key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkforward, key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkright, key: "d" }));
            } else if (parameters.where == "left") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.walkleft, key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkforward, key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkbackward, key: "s" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkright, key: "d" }));
            } else if (parameters.where == "forward-left") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.walkforward, key: "w" })), document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.walkleft, key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkbackward, key: "s" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkright, key: "d" }));
            }
          } else {
            defaultKeys.repeat = false;
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkforward, key: "w" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkleft, key: "a" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkbackward, key: "s" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.walkright, key: "d" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.sprint, key: "Shift" }));
          }
        } else if (type == "jump") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.jump, key: " " }));
          } else {
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.jump, key: " " }));
          }
        } else if (type == "shoot") {
          if (parameters.positive) {
            utils.options.get("Zoomed") || document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.zoom, key: "i" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.zoom, key: "i" }));
            setTimeout(() => {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.shoot, key: "f" }));
            }, 100);
          } else {
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.shoot, key: "f" }));
            document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.zoom, key: "i" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.zoom, key: "i" }));
            keyStates[keyBindings.shoot] = false;
            keyStates[keyBindings.zoom] = false;
          }
        } else if (type == "fire") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.shoot, key: "f" }));
          } else {
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.shoot, key: "f" }));
            keyStates[keyBindings.shoot] = false;
          }
        } else if (type == "zoom") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.zoom, key: "i" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.zoom, key: "i" }));
          }
        } else if (type == "reload") {
          document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.reload, key: "r" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.reload, key: "r" }));
        } else if (type == "throw") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.throwgrenade, key: "g" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.throwgrenade, key: "g" }));
          }
        } else if (type == "melee") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.melee, key: "b" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.melee, key: "b" }));
          }
        } else if (type == "swap") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: keyBindings.switchweapon, key: "y" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: keyBindings.switchweapon, key: "y" }));
          }
        }
      });
      if (utils.options.get("TouchDevice")) document.body.appendChild(TouchUI.domElement);
    </script>
  </body>
</html>
